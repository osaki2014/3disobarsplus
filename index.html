<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3D天気図ビューアープラス（学校スタイル）</title>

<!-- Google Fonts（丸ゴ） -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;600;800&display=swap" rel="stylesheet">

<!-- three.js & addons via importmap -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
  }
}
</script>

<style>
  :root{
    /* 学校版のやわらか配色 */
    --bg1:#f0f7ff;        /* 背景グラデ1 */
    --bg2:#e8fff6;        /* 背景グラデ2 */
    --panel:#ffffff;      /* パネル背景 */
    --muted:#64748b;      /* 説明文字 */
    --border:#dbe3ee;     /* 罫線 */
    --accent:#4f46e5;     /* アクセント（インディゴ） */
    --accent-2:#06b6d4;   /* サブ（シアン） */
    --chip: #f0f3ff;      /* チップ背景 */
  }

  /* 背景はやさしいグラデーション＋丸ゴ */
  html,body{
    height:100%; margin:0;
    background: linear-gradient(145deg, var(--bg1), var(--bg2));
    color:#2474c9;
    font-family:'M PLUS Rounded 1c',"Hiragino Maru Gothic ProN","Yu Gothic",Meiryo,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    letter-spacing:.01em;
  }

  #app{display:grid;grid-template-columns:1fr 420px;grid-template-rows:auto 48px 1fr;height:100%}
  #app[data-panel="closed"]{grid-template-columns:1fr 0}

  /* ヘッダー */
  header{
    grid-column:1/-1;display:flex;align-items:center;gap:.7rem;
    padding:.7rem 1rem;border-bottom:1px solid var(--border);
    background: linear-gradient(90deg,#ffffffdd,#ffffffdd);
    backdrop-filter: blur(6px);
    position:sticky;
    top: 0;
    z-index: 1000;
    }
  header h1{font-size:18px;margin:0;font-weight:800;display:flex;align-items:center;gap:.5rem}
  header h1::before{content:"🌤️"; font-size:20px}
  header .sp{flex:1}
  header a{font-size:13px;color:var(--accent);text-decoration:none}
  header a:hover{text-decoration:underline}
  header button,header label,header select{
    background:#fff;border:1px solid var(--border);color:#0f172a;
    padding:.5rem .75rem;border-radius:.75rem;cursor:pointer;font-size:14px;
    box-shadow:0 2px 0 #0000000a; transition:transform .05s ease, box-shadow .2s ease, border-color .2s ease;
  }
  header button:hover, header select:hover{border-color:#c6d0e1}
  header button:active{transform:translateY(1px)}
  header input[type=file]{display:none}

  /* 再生UI（ヘッダ内） */
  .playbar{display:flex; align-items:center; gap:.55rem; margin-left:.4rem}
  #playBtn{
    width:44px;height:44px;border-radius:999px;
    display:inline-grid;place-items:center;font-size:18px;
  }
  #playBtn[aria-pressed="true"]{ color:#fff; background:var(--accent); }
  #playDelay{padding:.4rem .55rem; min-width:80px}

  /* タブバー（もっと“タブらしく”） */
  .tabs{
    grid-column:1/-1;
    display:flex; align-items:flex-end; gap:.35rem;
    padding:0 .75rem; border-bottom:1px solid var(--border);
    background:linear-gradient(0deg,#ffffffdd,#ffffffdd);
    backdrop-filter: blur(6px);
    position:relative; 
    z-index: 10;
  }
  .tab{
    position:relative;
    background:#fff;
    border:1px solid var(--border);
    border-bottom:none;
    padding:.5rem .9rem;
    border-top-left-radius:.8rem; border-top-right-radius:.8rem;
    color:#334155; font-weight:700; font-size:13px;
    box-shadow:0 -2px 0 #00000008 inset, 0 6px 12px #0000000a;
    transform: translateY(1px);
  }
  .tab::after{
    content:""; position:absolute; left:-1px; right:-1px; bottom:-1px; height:1px; background:transparent;
  }
  .tab.active{
    color:#111827;
    box-shadow:0 -2px 0 #4f46e530 inset, 0 10px 18px #00000012;
    border-color:#cfd9ea;
  }
  .tab .file-ico{margin-right:.4rem; opacity:.9}
  .tab .close{
    margin-left:.5rem; padding:.2rem .4rem; border-radius:.4rem;
    background:#f8fafc; border:1px solid #e2e8f0; color:#64748b;
    font-size:12px; font-weight:600; cursor:pointer;
    transition:all .15s ease; min-width:20px; text-align:center;
  }
  .tab .close:hover{
    background:#fef2f2; border-color:#fecaca; color:#dc2626;
    transform:scale(1.05);
  }
  .tab .close:active{transform:scale(0.95)}
  .tabs .sp{flex:1}

  /* ビューア */
  #viewer{position:relative;background:#fff;border-top:1px solid var(--border)}
  #c{width:100%;height:100%}
  #overlay{
    position:absolute;left:12px;bottom:12px;
    padding:.55rem .7rem;background:#ffffffcc;border:1px solid var(--border);
    border-radius:.8rem;font-size:13px;color:#334155;box-shadow:0 4px 20px #00000010;
  }
  #overlay::before{content:"🖱️ ";}

  /* ドラッグHUD */
  #dragHud{
    position:absolute;pointer-events:none;transform:translate(-50%,-130%);
    padding:.3rem .5rem;font-size:13px;border-radius:.5rem;background:#0009;color:#fff;border:1px solid #0003;display:none;white-space:nowrap
  }

  /* サイドバー */
  #sidebar{
    background:var(--panel);border-left:1px solid var(--border);overflow:auto;padding:1rem .9rem
  }
  #app[data-panel="closed"] #sidebar{display:none}
  .section{margin-bottom:1rem}
  .section h2{font-size:14px;margin:.4rem 0 .2rem;font-weight:800;display:flex;align-items:center;gap:.4rem}
  .section h2 .emo{opacity:.9}

  .row{display:grid;grid-template-columns:1fr auto;gap:.7rem;align-items:center;margin:.5rem 0}
  .row label{font-size:13px;color:var(--muted)}
  #list{display:grid;gap:.7rem}

  /* カード（やさしい角と色） */
  .card{
    border:1px solid var(--border);background:#fff;border-radius:1rem;padding:.7rem .7rem .6rem;
    box-shadow:0 4px 14px #0000000a
  }
  .card .t{display:flex;gap:.6rem;align-items:center;margin-bottom:.35rem}
  .chip{
    display:inline-flex;align-items:center;gap:.4rem;border:1px solid var(--border);
    background:var(--chip); padding:.25rem .55rem;border-radius:999px;font-size:12px;font-weight:700;color:#334155
  }
  .small{font-size:12px}
  .muted{color:#6b7280;font-size:12px;margin-left:.4rem}
  canvas.grabbing{cursor:grabbing}
  canvas.hovering{cursor:ns-resize}

  /* メニュー（開く/書き出し） */
  .menu{position:absolute; z-index:10; background:#fff; border:1px solid var(--border); border-radius:.9rem; box-shadow:0 12px 32px #0002; padding:.35rem; display:none; min-width:200px}
  .menu.open{display:block}
  .menu button{display:block; width:100%; text-align:left; padding:.65rem .9rem; border:none; background:transparent; border-radius:.7rem; font-size:14px}
  .menu button:hover{background:#f1f5f9}
  .menu .sep{height:1px; background:#e5e7eb; margin:.25rem .25rem}
  .card.focus-ring{outline:2px solid var(--accent); box-shadow:0 0 0 4px #4f46e530}

  /* スライダーを少し太く・大きめに */
  input[type=range]{width:220px}
  input[type=range]::-webkit-slider-thumb{
    appearance:none; width:18px;height:18px;border-radius:12px;background:var(--accent);
    border:2px solid #fff; box-shadow:0 1px 3px #00000022; margin-top:-7px
  }
  input[type=range]::-webkit-slider-runnable-track{height:6px;border-radius:999px;background:linear-gradient(90deg,var(--accent),var(--accent-2))}
  input[type=color]{width:36px;height:28px;border-radius:8px;border:1px solid var(--border);padding:0}

  /* セレクトとボタンに絵文字 */
  #openBtn::before{content:"📂 ";} #exportBtn::before{content:"💾 ";} #panelToggle::before{content:"🧰 ";}
</style>
</head>
<body>
<div id="app" data-panel="open">
  <header>
    <h1>3D天気図ビューアープラス</h1>

    <a href="https://www.data.jma.go.jp/yoho/wxchart/quickmonthly.html" target="_blank" rel="noopener noreferrer">
      気象庁による「過去の実況天気図」
    </a>

    <span class="sp"></span>

    <!-- 再生UI（ヘッダ内配置） -->
    <div class="playbar" title="タブ自動巡回">
      <button id="playBtn" aria-pressed="false" title="自動でタブを巡回">▶</button>
      <select id="playDelay">
        <option value="0.3">0.3秒</option>
        <option value="0.5">0.5秒</option>
        <option value="1" selected>1秒</option>
        <option value="1.5">1.5秒</option>
        <option value="2">2秒</option>
      </select>
    </div>

    <select id="projection" title="カメラの投影法">
      <option value="persp" selected>透視図法</option>
      <option value="ortho">正射影図法</option>
    </select>
    <select id="viewSelect" title="見やすい向きに切り替え">
      <option value="all">斜め視点</option>
      <option value="top">真上（XY）</option>
      <option value="front">正面（ZX）</option>
      <option value="side">側面（ZY）</option>
    </select>

    <!-- 開く（統合） -->
    <button id="openBtn">開く ▾</button>
    <input id="fileRaw" type="file" accept=".svg,.svgz,image/svg+xml,application/gzip">
    <input id="fileSaved" type="file" accept=".svg">
    <div id="openMenu" class="menu">
      <button data-act="open-raw">SVG/SVGZを開く（気象庁など）</button>
      <div class="sep"></div>
      <button data-act="open-saved">保存SVGを開く（本アプリ）</button>
    </div>

    <!-- 書き出し（統合） -->
    <button id="exportBtn">書き出し ▾</button>
    <div id="exportMenu" class="menu">
      <button data-act="export-stl">STLを書き出し</button>
      <div class="sep"></div>
      <button data-act="save-svg">SVGを保存</button>
    </div>

    <button id="panelToggle">パネル</button>
  </header>
<!-- ▼追加：タブバー -->
<div id="tabbar" class="tabs"></div>

  <div id="viewer">
    <canvas id="c"></canvas>
    <div id="overlay">ドラッグで回転 / 右ドラッグで平行移動 / ホイールでズーム / 線をドラッグで高さ変更（Shift=ゆっくり / Alt=大きく）/ 手描きON: 視点と平行な原点平面に描画</div>
    <div id="dragHud"></div>
  </div>

  <aside id="sidebar">
    <div class="section">
      <h2><span class="emo">⚙️</span> 全体設定</h2>
      <div class="row"><label>背景色</label><input id="bgColor" type="color" value="#dff0ff"></div>
      <div class="row"><label>基準（軸＆キューブ）</label><input id="basisVisible" type="checkbox" checked></div>
      <div class="row"><label>グリッド（XY/ZX）</label><input id="gridVisible" type="checkbox" checked></div>
      <div class="row"><label>高さ倍率（Z）</label><input id="heightScale" type="range" min="0.1" max="20" step="0.1" value="5"></div>
      <div class="row"><label>ドラッグ感度</label><input id="dragSensitivity" type="range" min="0.05" max="2.0" step="0.05" value="0.3"></div>
      <div class="row"><label>サンプリング密度（読み込み）</label><input id="sample" type="range" min="32" max="1000" step="1" value="240"></div>
    </div>

    <div class="section">
      <h2><span class="emo">🗺️</span> 天気図画像（下敷き）</h2>
      <div class="row"><label>表示する</label><input id="imgVisible" type="checkbox" checked></div>
      <div class="row"><label>不透明度</label><input id="imgOpacity" type="range" min="0" max="1" step="0.01" value="0.9"></div>
      <div class="row"><label>高さ（Zオフセット）</label><input id="imgHeight" type="range" min="-200" max="200" step="0.1" value="-0.1"></div>
    </div>

    <div class="section">
      <h2><span class="emo">🤖</span> 自動高さ（ラベル順・色も連動）</h2>
      <div class="row"><label>自動高さを使う</label><input id="autoMode" type="checkbox"></div>
      <div class="row"><label>間隔倍率</label><input id="gapFactor" type="range" min="0.2" max="3" step="0.05" value="1"></div>
      <div class="row"><label>平坦 ←→ 初期間隔</label><input id="autoBlend" type="range" min="0" max="1" step="0.01" value="1"></div>
      <div class="row"><span class="muted" id="labelInfo">ラベル未解析</span><span></span></div>
    </div>

    <!-- 表示モード（パイプ/壁） -->
    <div class="section">
      <h2><span class="emo">🎛️</span> 表示モード</h2>
      <div class="row"><label>パイプ（Tube）</label><input id="modePipe" type="checkbox" checked></div>
      <div class="row"><label>壁（Wall：帯押し出し）</label><input id="modeWall" type="checkbox"></div>
      <div class="row"><label>パイプ直径</label><input id="pipeDia" type="range" min="0.2" max="12" step="0.1" value="6.0"></div>
      <div class="row"><label>壁の厚さ（帯幅）</label><input id="wallThick" type="range" min="0.2" max="16" step="0.1" value="2.5"></div>
      <div class="row"><label>壁の不透明度</label><input id="wallOpacity" type="range" min="0" max="1" step="0.01" value="0.9"></div>
      <div class="row"><span class="muted">※パイプ/壁は同時表示可。ドラッグは表示中の形状に有効。</span><span></span></div>
    </div>
    <div class="row"><label>面（Fill）</label><input id="modeFill" type="checkbox"></div>
    <div class="row">
      <label>面の張り方</label>
      <select id="fillSide">
        <option value="inside" selected>輪郭の内側</option>
        <option value="outside">輪郭の外側</option>
      </select>
    </div>
    <div class="row"><label>面の不透明度</label><input id="fillOpacity" type="range" min="0" max="1" step="0.01" value="0.35"></div>

    <!-- 手書き3D描画 -->
    <div class="section">
      <h2><span class="emo">✍️</span> 手書き3D描画</h2>
      <div class="row"><label>有効（描画モード）</label><input id="drawEnable" type="checkbox"></div>
      <div class="row">
        <label>形状</label>
        <select id="drawShape">
          <option value="tube" selected>円断面（チューブ）</option>
          <option value="rect">長方形断面（帯）</option>
        </select>
      </div>
      <div class="row"><label>色</label><input id="drawColor" type="color" value="#ff0066"></div>
      <div class="row"><label>円の直径 / 帯の幅</label><input id="drawDiaOrWidth" type="range" min="0.5" max="30" step="0.5" value="8"></div>
      <div class="row"><label>帯の厚み（長方形のみ）</label><input id="drawThickness" type="range" min="0.2" max="20" step="0.2" value="3"></div>
      <div class="row"><label>なめらかさ</label><input id="drawSampling" type="range" min="2" max="20" step="1" value="6"></div>
      <div class="row"><span class="muted">※描く面は「現在の視点に平行」＋「原点を通る」平面です。</span><span></span></div>
    </div>

    <div class="section">
      <h2><span class="emo">🧵</span> 等圧線リスト</h2>
      <div id="list"></div>
    </div>
  </aside>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
import { STLExporter } from 'three/addons/exporters/STLExporter.js';
import * as pako from 'https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.esm.mjs';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

const PICK_TUBE_SCALE = 2.8;
const PICK_BAND_SCALE = 1.8;

/* ==== DOM refs ==== */
const ui = {
  app: document.getElementById('app'),
  canvas: document.getElementById('c'),
  dragHud: document.getElementById('dragHud'),
  projection: document.getElementById('projection'),
  viewSelect: document.getElementById('viewSelect'),
  openBtn: document.getElementById('openBtn'),
  exportBtn: document.getElementById('exportBtn'),
  openMenu: document.getElementById('openMenu'),
  exportMenu: document.getElementById('exportMenu'),
  fileRaw: document.getElementById('fileRaw'),
  fileSaved: document.getElementById('fileSaved'),
  panelToggle: document.getElementById('panelToggle'),
  bgColor: document.getElementById('bgColor'),
  basisVisible: document.getElementById('basisVisible'),
  gridVisible: document.getElementById('gridVisible'),
  heightScale: document.getElementById('heightScale'),
  dragSensitivity: document.getElementById('dragSensitivity'),
  sample: document.getElementById('sample'),
  imgVisible: document.getElementById('imgVisible'),
  imgOpacity: document.getElementById('imgOpacity'),
  imgHeight: document.getElementById('imgHeight'),
  autoMode: document.getElementById('autoMode'),
  gapFactor: document.getElementById('gapFactor'),
  autoBlend: document.getElementById('autoBlend'),
  labelInfo: document.getElementById('labelInfo'),
  modePipe: document.getElementById('modePipe'),
  modeWall: document.getElementById('modeWall'),
  pipeDia: document.getElementById('pipeDia'),
  wallThick: document.getElementById('wallThick'),
  wallOpacity: document.getElementById('wallOpacity'),
  list: document.getElementById('list'),
  drawEnable: document.getElementById('drawEnable'),
  drawShape: document.getElementById('drawShape'),
  drawColor: document.getElementById('drawColor'),
  drawDiaOrWidth: document.getElementById('drawDiaOrWidth'),
  drawThickness: document.getElementById('drawThickness'),
  drawSampling: document.getElementById('drawSampling'),
  playBtn: document.getElementById('playBtn'),
  playDelay: document.getElementById('playDelay'),
  modeFill: document.getElementById('modeFill'),
  fillSide: document.getElementById('fillSide'),
  fillOpacity: document.getElementById('fillOpacity'),
};
/* ==== タブ管理 ==== */
const tabbar = document.getElementById('tabbar');
let tabs = [];           // {id,title,type,raw,only,project, cam:{pos,target,ortho?}, items:[]}
let activeTabId = null;
let _tabSeq = 0;
// ▼追加（グローバル）
let suppressFit = false;
let suppressStateSave = false;

function maybeFit(){
  if(!suppressFit) fitView(chartGroup);
}
function captureCamera(){
  return {
    pos: camera.position.toArray(),
    target: controls.target.toArray(),
    ortho: camera.isOrthographicCamera
  };
}
function captureItemsState(){
  return items.map(item => ({
    id: itemSignature(item),                   // ← 署名も保存
    height: item.height,
    userColor: item.userColor,
    visible: item.ui?.vis?.checked ?? true
  }));
}
function restoreItemsState(itemsState){
  if(!itemsState || !items.length) return;

  // id -> state
  const map = new Map(itemsState.map(s => [s.id, s]));

  for(const it of items){
    const st = map.get(itemSignature(it));
    if(!st) continue;
    it.height    = st.height ?? 0;
    it.userColor = st.userColor ?? null;
    if(it.ui?.vis) it.ui.vis.checked = (st.visible ?? true);
  }

  updateHeightsAndColors();
  applyModeVisibility();
}

function syncItemUIs(){
  for(const it of items){
    if (it.ui?.slider) it.ui.slider.value = it.height;
    if (it.ui?.num)    it.ui.num.value    = it.height.toFixed(2);
    if (it.ui?.vis)    it.ui.vis.checked  = (it.ui?.vis?.checked ?? true);
    if (it.ui?.color)  it.ui.color.value  =
      it.userColor ? it.userColor : `#${it.pipeMesh.material.color.getHexString()}`;
  }
}
function restoreCamera(cam){
  if(!cam) return;
  if(cam.ortho) useOrthographic(); else usePerspective();
  camera.position.fromArray(cam.pos);
  controls.target.fromArray(cam.target);
  controls.update();
  resize();
}

function renderTabbar(){
  tabbar.innerHTML = '';
  for(const t of tabs){
    const el = document.createElement('div');
    el.className = 'tab' + (t.id===activeTabId ? ' active' : '');
    el.innerHTML = `<span class="name">${t.title}</span><button class="close" title="閉じる">🗑️</button>`;
    el.querySelector('.name').onclick = ()=> activateTab(t.id);
    el.querySelector('.close').onclick = (e)=>{ e.stopPropagation(); closeTab(t.id); };
    tabbar.appendChild(el);
  }
  // 再生中なら、タブ構成が変わったときも巡回を継続
  if(play.on) scheduleNext();
}
function saveActiveTabState(){
  const t = tabs.find(x => x.id === activeTabId);
  if (t) {
    t.itemsState = captureItemsState();
    t.cam = captureCamera();
  }
}
async function activateTab(id){
  const t = tabs.find(x=>x.id===id); if(!t) return;

  // 現在タブの保存（既存）
  const cur = tabs.find(x=>x.id===activeTabId);
  if(cur){ cur.cam = captureCamera(); cur.itemsState = captureItemsState(); }

  activeTabId = id;
  renderTabbar();

  suppressFit = true;
  suppressStateSave = true; 
  try{
    // ★UIを見た目としても同期したい場合はここで値を反映（任意）
    if(t.params){
      ui.sample.value     = t.params.sampleN;
      ui.pipeDia.value    = t.params.pipeDia;
      ui.wallThick.value  = t.params.wallThick;
      ui.wallOpacity.value= t.params.wallOpacity;
    }

    if(t.type==='project'){
      await loadProjectSVG(t.project);
    }else if(t.type==='raw'){
      lastRawSvgText = t.rawBg;
      lastSvgDims    = t.svgDims;
      await buildOrUpdateWeatherPlane(lastRawSvgText);
      // ★ここ：タブ固有パラメータを渡す
      const hasState = Array.isArray(t.itemsState) && t.itemsState.length;
      await loadSVGFromString(t.only, {...(t.params||{}), suppressAuto: hasState});
    }
  }catch(err){ console.error('タブ切替エラー', err); }
  finally{
    suppressFit = false;
  }

  // 状態復元（既存）
  if(t.itemsState){
    restoreItemsState(t.itemsState);
    syncItemUIs();
  }
  suppressStateSave = false;
  saveActiveTabState(); 
  if(!play.on){
    if(t.cam) restoreCamera(t.cam);
    else      maybeFit();
  }
  if(play.on) scheduleNext();
}

function closeTab(id){
  const i = tabs.findIndex(x=>x.id===id);
  if(i<0) return;
  tabs.splice(i,1);
  if(!tabs.length){
    // 何も無くなったら空表示
    rootLines.clear(); items=[]; ui.list.innerHTML='';
    weatherPlane?.parent?.remove(weatherPlane); weatherPlane=null;
    activeTabId=null;
    renderTabbar();
    return;
  }
  // 直前 or 先頭をアクティブ
  const next = tabs[Math.max(0, i-1)].id;
  activateTab(next);
  if(play.on) scheduleNext();
}

function addTabFromRaw(filename, rawSvgText, onlyIsobars, svgDims){
  const id = ++_tabSeq;
  tabs.push({
    id,
    title: filename || '無題.svg',
    type: 'raw',
    rawBg: new XMLSerializer().serializeToString(
      new DOMParser().parseFromString(rawSvgText,'image/svg+xml').documentElement
    ),
    only: onlyIsobars,
    svgDims,
    cam: captureCamera(),
    itemsState: null,
    // ★ここ
    params: {
      sampleN: parseInt(ui.sample.value,10),
      pipeDia: parseFloat(ui.pipeDia.value),
      wallThick: parseFloat(ui.wallThick.value),
      wallOpacity: parseFloat(ui.wallOpacity.value),
    }
  });
  activateTab(id);
}
function addTabFromProject(filename, projectText){
  const id = ++_tabSeq;
  tabs.push({
    id,
    title: filename || '保存データ',
    type:'project',
    project: projectText,
    cam: captureCamera(),
    itemsState: null,
    // ★保存SVGは 3D形状が埋め込まれているが、再構築時の保険として保持
    params: {
      sampleN: parseInt(ui.sample.value,10),
      pipeDia: parseFloat(ui.pipeDia.value),
      wallThick: parseFloat(ui.wallThick.value),
      wallOpacity: parseFloat(ui.wallOpacity.value),
    }
  });
  activateTab(id);
}

/* ==== 再生（タブ巡回） ==== */
const play = {
  on: false,
  timer: null,
  btn: document.getElementById('playBtn'),
  delay: document.getElementById('playDelay'),
};

function getIntervalMs(){
  const delay = parseFloat(play.delay.value || '1');   // 秒
  return Math.max(200, delay * 1000);
}
function scheduleNext(){
  clearTimeout(play.timer);
  if(!play.on || tabs.length <= 1) return;
  play.timer = setTimeout(()=>{
    // 次のタブへ
    const idx = tabs.findIndex(t=>t.id===activeTabId);
    const next = tabs[(idx+1) % tabs.length];
    activateTab(next.id);
    scheduleNext();
  }, getIntervalMs());
}
function setPlaying(state){
  play.on = !!state;
  play.btn.setAttribute('aria-pressed', play.on ? 'true' : 'false');
  play.btn.textContent = play.on ? '⏸' : '▶';
  clearTimeout(play.timer);
  if(play.on) scheduleNext();
}

// UIイベント
play.btn.addEventListener('click', ()=> setPlaying(!play.on));
play.delay.addEventListener('change', ()=>{ if(play.on) scheduleNext(); });

/* ==== renderer / scene ==== */
const renderer = new THREE.WebGLRenderer({canvas: ui.canvas, antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
scene.background = new THREE.Color(ui.bgColor.value);

/* ==== cameras & controls ==== */
let controls, camera;
const perspCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 50000);
perspCamera.up.set(0,0,1);
perspCamera.position.set(450,300,200);

const orthoCamera = new THREE.OrthographicCamera(-500,500,500,-500,-50000,50000);
orthoCamera.up.set(0,0,1);
orthoCamera.position.copy(perspCamera.position);

function makeControls(cam){
  if(controls) controls.dispose();
  controls = new OrbitControls(cam, renderer.domElement);
  controls.enableDamping = true;
  controls.screenSpacePanning = false;
}
function setOrthoFrustum(){
  const v=document.getElementById('viewer'); const aspect=v.clientWidth/v.clientHeight;
  const box=new THREE.Box3().setFromObject(chartGroup);
  const s=new THREE.Vector3(); box.getSize(s);
  const maxDim=Math.max(s.x,s.y,s.z,100);
  const halfH=maxDim*0.7, halfW=halfH*aspect;
  orthoCamera.left=-halfW; orthoCamera.right=halfW; orthoCamera.top=halfH; orthoCamera.bottom=-halfH;
  orthoCamera.near=-maxDim*10; orthoCamera.far=maxDim*10; orthoCamera.updateProjectionMatrix();
}
function usePerspective(){ perspCamera.position.copy(camera.position); camera=perspCamera; makeControls(camera); controls.target.copy(_target); controls.update(); }
function useOrthographic(){ orthoCamera.position.copy(camera.position); setOrthoFrustum(); camera=orthoCamera; makeControls(camera); controls.target.copy(_target); controls.update(); }
let _target = new THREE.Vector3();
camera = perspCamera; makeControls(camera);

/* ==== lights / grid / basis ==== */
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dl=new THREE.DirectionalLight(0xffffff,0.95); dl.position.set(400,300,500); scene.add(dl);
const gridXY=new THREE.GridHelper(1000,100,0xffffff,0xffffff); gridXY.rotation.x=Math.PI/2; gridXY.material.opacity=.6; gridXY.material.transparent=true; scene.add(gridXY);
const gridZX=new THREE.GridHelper(1000,100,0xffffff,0xffffff); gridZX.material.opacity=.35; gridZX.material.transparent=true; scene.add(gridZX);

const basis=new THREE.Group();
basis.add(new THREE.ArrowHelper(new THREE.Vector3(1,0,0),new THREE.Vector3(),300,0xff5f5f,50,20));
basis.add(new THREE.ArrowHelper(new THREE.Vector3(0,1,0),new THREE.Vector3(),300,0x14b8a6,50,20));
basis.add(new THREE.ArrowHelper(new THREE.Vector3(0,0,1),new THREE.Vector3(),300,0x60a5fa,50,20));
const fontLoader=new FontLoader();
fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',(font)=>{
  const mk=(ch,col,pos)=>{
    const g=new TextGeometry(ch,{font,size:42,height:5});
    g.computeBoundingBox();
    const m=new THREE.MeshBasicMaterial({color:col});
    const mesh=new THREE.Mesh(g,m);
    const w=g.boundingBox.max.x-g.boundingBox.min.x;
    mesh.position.set(pos.x-w/2,pos.y,pos.z);
    basis.add(mesh);
  };
  mk('X',0xff5f5f,{x:320,y:-20,z:0}); mk('Y',0x14b8a6,{x:0,y:320,z:0}); mk('Z',0x60a5fa,{x:0,y:-20,z:320});
});
const cube=new THREE.Mesh(new THREE.BoxGeometry(60,60,60),[
  new THREE.MeshStandardMaterial({color:0xff5f5f,roughness:.35,metalness:.1}),
  new THREE.MeshStandardMaterial({color:0xff5f5f,roughness:.35,metalness:.1}),
  new THREE.MeshStandardMaterial({color:0x14b8a6,roughness:.35,metalness:.1}),
  new THREE.MeshStandardMaterial({color:0x14b8a6,roughness:.35,metalness:.1}),
  new THREE.MeshStandardMaterial({color:0x60a5fa,roughness:.35,metalness:.1}),
  new THREE.MeshStandardMaterial({color:0x60a5fa,roughness:.35,metalness:.1}),
]); cube.position.set(0,0,30); basis.add(cube); scene.add(basis);

/* ==== containers ==== */
const chartGroup=new THREE.Group(); scene.add(chartGroup);
const rootLines=new THREE.Group(); chartGroup.add(rootLines);
/* item:
   {
     pipeMesh, wallMesh, pickPipeMesh, pickWallMesh,
     activeMesh, activePick,
     pathPoints: THREE.Vector3[], path2D: {x,y}[],
     height, ui, userColor, wallExtrudedZ, kind
   }
*/
let items=[];
let weatherPlane=null, lastSvgDims=null, lastRawSvgText="";
let linesOffset = new THREE.Vector3(0,0,0);

/* ==== render loop / resize ==== */
function resize(){
  const v=document.getElementById('viewer');
  renderer.setSize(v.clientWidth,v.clientHeight,false);
  if(camera.isPerspectiveCamera){ camera.aspect=v.clientWidth/v.clientHeight; camera.updateProjectionMatrix(); }
  else setOrthoFrustum();
}
addEventListener('resize',resize); resize();
(function anim(){
  requestAnimationFrame(anim);
  controls.update(); renderer.render(scene,camera);
})();

/* ==== views ==== */
function fitView(target=chartGroup){
  const b=new THREE.Box3().setFromObject(target); const sz=new THREE.Vector3(), cen=new THREE.Vector3();
  b.getSize(sz); b.getCenter(cen); if(!(isFinite(sz.x)&&isFinite(sz.y))) return;
  _target.copy(cen);
  if(camera.isPerspectiveCamera){
    const maxDim=Math.max(sz.x,sz.y,sz.z);
    const dist=maxDim*1.2/Math.tan(THREE.MathUtils.degToRad(perspCamera.fov*0.5));
    const dir=new THREE.Vector3(.75,.55,.35).normalize();
    camera.position.copy(cen.clone().add(dir.multiplyScalar(dist)));
    camera.near=Math.max(.1,dist/1000); camera.far=dist*1000; camera.updateProjectionMatrix();
  }else{
    setOrthoFrustum();
    camera.position.copy(new THREE.Vector3(.75,.55,.35).normalize().multiplyScalar(Math.max(sz.x,sz.y,sz.z)*2).add(cen));
  }
  controls.target.copy(cen); controls.update();
}
function viewTop(){ const b=new THREE.Box3().setFromObject(chartGroup),c=new THREE.Vector3(),s=new THREE.Vector3(); b.getCenter(c); b.getSize(s); const dist=Math.max(s.x,s.y,s.z)*2+1; camera.position.set(c.x,c.y,c.z+dist); _target.copy(c); controls.target.copy(c); controls.update(); if(!camera.isPerspectiveCamera) setOrthoFrustum(); }
function viewFront(){ const b=new THREE.Box3().setFromObject(chartGroup),c=new THREE.Vector3(),s=new THREE.Vector3(); b.getCenter(c); b.getSize(s); const dist=Math.max(s.x,s.y,s.z)*2+1; camera.position.set(c.x,c.y-dist,c.z); _target.copy(c); controls.target.copy(c); controls.update(); if(!camera.isPerspectiveCamera) setOrthoFrustum(); }
function viewSide(){ const b=new THREE.Box3().setFromObject(chartGroup),c=new THREE.Vector3(),s=new THREE.Vector3(); b.getCenter(c); b.getSize(s); const dist=Math.max(s.x,s.y,s.z)*2+1; camera.position.set(c.x+dist,c.y,c.z); _target.copy(c); controls.target.copy(c); controls.update(); if(!camera.isPerspectiveCamera) setOrthoFrustum(); }

/* ==== helpers ==== */
function colorFromHeight(h,maxH){ if(maxH<=0 || h<=0) return new THREE.Color(0xff0000); const t=Math.min(Math.max(h/maxH,0),1); const c=new THREE.Color(); c.setHSL((2/3)*t,1,0.55); return c; }
function currentMaxHeightStrict(){ if(!items.length) return 0; let m=0; for(const it of items) if(it.height>m) m=it.height; return m; }

/* ==== geometry ==== */
const EDGE_TOL = 1.0;      // ← ユーザー希望の ±1px
const INTERSECT_EPS = 1e-4; // 交点計算の数値許容も少し緩める
function getFillBoundsRect(pad = 0){
  // 等圧線全体の外接矩形を返す
  return allBounds(pad);
}
// 全アイテムのX,Y範囲から全体矩形を計算
function allBounds(pad=0){
  let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
  for(const it of items){
    for(const p of it.pathPoints){
      if(p.x < minX) minX = p.x;
      if(p.x > maxX) maxX = p.x;
      if(p.y < minY) minY = p.y;
      if(p.y > maxY) maxY = p.y;
    }
  }
  if(!isFinite(minX)) return {minX:-500,maxX:500,minY:-500,maxY:500};
  return {minX:minX-pad, maxX:maxX+pad, minY:minY-pad, maxY:maxY+pad};
}


// ===================== buildFillGeometry（完全版・決定論） =====================
// points3: THREE.Vector3[]  … 等圧線の頂点（XYを使用）
// mode   : 'inside' | 'outside'
function buildFillGeometry(points3, mode = 'inside') {
  // ── 矩形：等圧線の全体BBox（背景は使わない） ─────────────────────────
  const R = allBounds(0);     // {minX,maxX,minY,maxY}
  const SNAP = 1.0;           // 辺スナップしきい値（px）
  const EPS  = 1e-7;
  const V2 = (x,y)=> new THREE.Vector2(x,y);

  // 角（反時計回り：BL→BR→TR→TL）
  const BL = V2(R.minX, R.minY);
  const BR = V2(R.maxX, R.minY);
  const TR = V2(R.maxX, R.maxY);
  const TL = V2(R.minX, R.maxY);

  // 辺ID
  const EDGE = { B:0, R:1, T:2, L:3 };
  const isH  = e => e===EDGE.B || e===EDGE.T;

  // ── 補助 ─────────────────────────────────────────────────────────
  const near = (a,b,t=SNAP)=> Math.abs(a-b)<=t;
  const samePt = (p,q,t=1e-6)=> p.distanceTo(q)<=t;

  function edgeOfPoint(p){
    if (near(p.y,R.minY) && p.x>=R.minX-SNAP && p.x<=R.maxX+SNAP) return EDGE.B;
    if (near(p.x,R.maxX) && p.y>=R.minY-SNAP && p.y<=R.maxY+SNAP) return EDGE.R;
    if (near(p.y,R.maxY) && p.x>=R.minX-SNAP && p.x<=R.maxX+SNAP) return EDGE.T;
    if (near(p.x,R.minX) && p.y>=R.minY-SNAP && p.y<=R.maxY+SNAP) return EDGE.L;
    return null;
  }
  function snapToRect(p){
    // 最も近い辺に正確に投影
    const dxL=Math.abs(p.x-R.minX), dxR=Math.abs(p.x-R.maxX);
    const dyB=Math.abs(p.y-R.minY), dyT=Math.abs(p.y-R.maxY);
    const m=Math.min(dxL,dxR,dyB,dyT);
    const q=p.clone();
    if(m===dxL) q.x=R.minX; else if(m===dxR) q.x=R.maxX; else if(m===dyB) q.y=R.minY; else q.y=R.maxY;
    return q;
  }
  // 反時計回りの通しパラメータ u∈[0,4)
  function rectU(p){
    const w=R.maxX-R.minX, h=R.maxY-R.minY;
    if (near(p.y,R.minY)) return 0 + (p.x-R.minX)/w;
    if (near(p.x,R.maxX)) return 1 + (p.y-R.minY)/h;
    if (near(p.y,R.maxY)) return 2 + (R.maxX-p.x)/w;
    // L
    return 3 + (R.maxY-p.y)/h;
  }
  function rectPointAt(u){
    const w=R.maxX-R.minX, h=R.maxY-R.minY;
    const k=((Math.floor(u)%4)+4)%4, t=u-k;
    if(k===0) return V2(R.minX + t*w, R.minY);
    if(k===1) return V2(R.maxX, R.minY + t*h);
    if(k===2) return V2(R.maxX - t*w, R.maxY);
    return V2(R.minX, R.maxY - t*h);
  }
  // 矩形上 P→Q を CCW/CW にたどる角列（PとQ含む）。中間角だけ増える。
  function rectArc(P, Q, dir /*'ccw'|'cw'*/){
    let u0 = rectU(P), u1 = rectU(Q);
    // u1 を u0 側に巻いて単調に進める
    if (dir==='ccw' && u1<=u0) u1 += 4;
    if (dir==='cw'  && u1>=u0) u1 -= 4;

    const verts=[P.clone()];
    if (dir==='ccw'){
      // u0→u1 の間の整数境界（=角）を順に
      for(let k=Math.ceil(u0-EPS); k<u1-EPS; k++){
        verts.push(rectPointAt(k));
      }
    }else{
      // u0→u1 を負方向に
      for(let k=Math.floor(u0+EPS); k>u1+EPS; k--){
        verts.push(rectPointAt(k));
      }
    }
    verts.push(Q.clone());
    return verts;
  }
  // ポリライン A(sA)→…→B(sB) を抽出（A,Bは {pt,s}）
  function polySliceBetween(poly2, A, B){
    const out=[A.pt.clone()];
    const iA=Math.floor(A.s), iB=Math.floor(B.s);
    if(A.s<=B.s){
      for(let i=iA+1;i<=iB;i++) out.push(poly2[i].clone());
    }else{
      for(let i=iA;i>iB;i--) out.push(poly2[i-1].clone());
    }
    out.push(B.pt.clone());
    return out;
  }
  // 線分交差
  function segSeg(a,b,c,d){
    const r = new THREE.Vector2().subVectors(b,a);
    const s = new THREE.Vector2().subVectors(d,c);
    const rxs = r.x*s.y - r.y*s.x;
    const qpxr = (c.x-a.x)*r.y - (c.y-a.y)*r.x;
    if (Math.abs(rxs)<1e-9) return null;
    const t=((c.x-a.x)*s.y - (c.y-a.y)*s.x)/rxs;
    const u=((c.x-a.x)*r.y - (c.y-a.y)*r.x)/rxs;
    if(t>-1e-9&&t<1+1e-9&&u>-1e-9&&u<1+1e-9) return new THREE.Vector2(a.x+t*r.x, a.y+t*r.y);
    return null;
  }

  // ── 入力2D化＋端点スナップ ─────────────────────────────────
  const poly2 = points3.map(p=>{
    const v = new THREE.Vector2(p.x, p.y);
    const e = edgeOfPoint(v);
    if (e!==null) {
      // 正確に辺上へ
      if (e===EDGE.B||e===EDGE.T) v.y = (e===EDGE.B?R.minY:R.maxY);
      else                        v.x = (e===EDGE.L?R.minX:R.maxX);
      return v;
    }
    // 近ければ投影
    const nearRect = Math.min(
      Math.abs(v.x-R.minX), Math.abs(v.x-R.maxX),
      Math.abs(v.y-R.minY), Math.abs(v.y-R.maxY)
    ) <= SNAP;
    return nearRect ? snapToRect(v) : v;
  });

  // 閉曲線なら通常塗り（outerは穴あき）
  const closed = poly2.length>=3 && samePt(poly2[0], poly2[poly2.length-1], 1e-6);
  if (closed){
    if (mode==='inside') return new THREE.ShapeGeometry(new THREE.Shape(poly2));
    const outer = new THREE.Shape([BL,BR,TR,TL,BL]);
    outer.holes.push(new THREE.Path(poly2));
    return new THREE.ShapeGeometry(outer);
  }

  // ── 矩形との交点を集める（A=最初, B=最後） ─────────────────────
  const rectEdges = [[BL,BR],[BR,TR],[TR,TL],[TL,BL]];
  const xs=[];
  for(let i=0;i<poly2.length-1;i++){
    const a=poly2[i], b=poly2[i+1];
    for(const [c,d] of rectEdges){
      const h = segSeg(a,b,c,d);
      if(h){
        // polyパラメータ s = i + t
        const ab = new THREE.Vector2().subVectors(b,a);
        const t = Math.abs(ab.x)>Math.abs(ab.y)
          ? ((h.x-a.x)/(ab.x||1e-12))
          : ((h.y-a.y)/(ab.y||1e-12));
        xs.push({pt:h.clone(), s: i + THREE.MathUtils.clamp(t,0,1)});
      }
    }
  }
  // 端点自体が辺上なら交点として加える
  const pushIfOn = (p, sVal)=>{
    if(edgeOfPoint(p)!==null && !xs.some(h=>samePt(h.pt,p,1e-7))) xs.push({pt:p.clone(), s:sVal});
  };
  if(poly2.length){ pushIfOn(poly2[0],0); pushIfOn(poly2[poly2.length-1], poly2.length-1); }

  if(xs.length<2){
    // 念のため端点を最寄り辺に投影して補完
    if(poly2.length>=2){
      xs.push({pt:snapToRect(poly2[0]), s:0});
      xs.push({pt:snapToRect(poly2[poly2.length-1]), s:poly2.length-1});
    }else{
      return new THREE.ShapeGeometry(new THREE.Shape());
    }
  }
  xs.sort((a,b)=>a.s-b.s);
  const A = xs[0], B = xs[xs.length-1];

  // 等圧線側（A→…→B）
  const curvePart = polySliceBetween(poly2, A, B);

  // 端点の属する辺
  const eA = edgeOfPoint(A.pt) ?? edgeOfPoint(snapToRect(A.pt));
  const eB = edgeOfPoint(B.pt) ?? edgeOfPoint(snapToRect(B.pt));

  // ── 矩形側（B→…→A）の経路を「決め打ちルール」で構成 ────────────────
  let arcBA = null;

  if (eA === eB){
    // (1) 同一辺
    if (mode==='inside'){
      // 角を通らず同じ辺上を直結（短い方）
      arcBA = [B.pt.clone(), A.pt.clone()];
    }else{
      // 外側：残り三角を回る（どちら向きでも3角。ccwで固定）
      arcBA = rectArc(B.pt, A.pt, 'ccw'); // 3つの角を通る
    }
  } else if (isH(eA) === isH(eB)){
    // (2) 同一軸の反対辺（左右 or 上下）
    // 仕様：内側＝A→B を反時計回りに2角通過
    //       ⇒ B→A は時計回り
    //       外側＝その逆
    arcBA = (mode==='inside')
      ? rectArc(B.pt, A.pt, 'cw')   // ← A→B(CCW) と同義
      : rectArc(B.pt, A.pt, 'ccw'); // ← A→B(CW)
  } else {
    // (3) 異軸（隣接辺）
    // 仕様：内側＝共有する1角のみ、外側＝残り3角
    const arcCCW = rectArc(B.pt, A.pt, 'ccw');
    const arcCW  = rectArc(B.pt, A.pt, 'cw');
    const cntCCW = Math.max(0, arcCCW.length-2); // 中間角の数
    const cntCW  = Math.max(0, arcCW.length-2);
    if (mode==='inside'){
      // 1角側を選ぶ
      arcBA = (cntCCW===1) ? arcCCW : arcCW;
    }else{
      // 3角側
      arcBA = (cntCCW===3) ? arcCCW : arcCW;
    }
  }

  // ── ポリゴン結合：A→…→B（等圧線）＋ B→…→A（矩形） ─────────────────
  const polygon = [...curvePart, ...arcBA];
  if (!samePt(polygon[0], polygon[polygon.length-1])) polygon.push(polygon[0].clone());
  if (polygon.length < 3) return new THREE.ShapeGeometry(new THREE.Shape());
  return new THREE.ShapeGeometry(new THREE.Shape(polygon));
}


/* ===== ここからヘルパー ===== */
const near = (a,b,eps=1e-6)=> Math.abs(a-b)<=eps;

function rectLoop(minX,minY,maxX,maxY){
  return [
    new THREE.Vector2(minX,minY),
    new THREE.Vector2(maxX,minY),
    new THREE.Vector2(maxX,maxY),
    new THREE.Vector2(minX,maxY),
    new THREE.Vector2(minX,minY),
  ];
}
function edgeOfPoint(p, r, eps=1e-6){
  if (near(p.y,r.minY,eps)) return 'B';
  if (near(p.x,r.maxX,eps)) return 'R';
  if (near(p.y,r.maxY,eps)) return 'T';
  if (near(p.x,r.minX,eps)) return 'L';
  return null;
}
// 矩形周（反時計回り）の“通しパラメータ u∈[0,4)”
function projU(p, r){
  if (edgeOfPoint(p,r)==='B') return 0 + (p.x - r.minX)/(r.maxX-r.minX);
  if (edgeOfPoint(p,r)==='R') return 1 + (p.y - r.minY)/(r.maxY-r.minY);
  if (edgeOfPoint(p,r)==='T') return 2 + (r.maxX - p.x)/(r.maxX-r.minX);
  if (edgeOfPoint(p,r)==='L') return 3 + (r.maxY - p.y)/(r.maxY-r.minY);
  return 0;
}
function rectPointAtU(r, u){
  const k = Math.floor(u)%4, t = u - Math.floor(u);
  if (k===0) return new THREE.Vector2(r.minX + t*(r.maxX-r.minX), r.minY);
  if (k===1) return new THREE.Vector2(r.maxX, r.minY + t*(r.maxY-r.minY));
  if (k===2) return new THREE.Vector2(r.maxX - t*(r.maxX-r.minX), r.maxY);
  return new THREE.Vector2(r.minX, r.maxY - t*(r.maxY-r.minY));
}
// A→B の矩形“辺”経路（角のみ）を、指定回転方向で返す
function rectPathBetween(A, B, r, clockwise=true){
  let u0 = projU(A.pt, r), u1 = projU(B.pt, r);
  if (clockwise && u1>u0) u1 -= 4;
  if (!clockwise && u1<u0) u1 += 4;

  const verts = [];
  const corners = [0,1,2,3,4];
  for (let ci=0; ci<corners.length; ci++){
    const cu = corners[ci];
    if ((u0 < cu && cu < u1) || (u1 < cu && cu < u0)){
      verts.push(rectPointAtU(r, cu));
    }
  }
  verts.sort((a,b)=> (projU(a,r)-projU(b,r)) * (clockwise?-1:1));
  return verts.concat([B.pt.clone()]);
}
// B の“ペア”に当たる交点 P へ、ポリラインに沿って切り出す
function polylineSliceBetween(poly2, A, B){
  const out=[A.pt.clone()];
  const iA=Math.floor(A.s), iB=Math.floor(B.s);
  if (A.s <= B.s){
    for(let i=iA+1;i<=iB;i++) out.push(poly2[i].clone());
  }else{
    // 逆向き
    for(let i=iA;i>iB;i--) out.push(poly2[i-1].clone());
  }
  out.push(B.pt.clone());
  return out;
}
// 交点配列 xsByU を起点に、矩形→ポリライン→矩形…で1周ループを構成
function weaveLoop(xsByU, pair, indexById, rect, clockwise, poly2){
  const start = xsByU[0];
  let cur = start;
  const res = [cur.pt.clone()];
  let guard = 0, m = xsByU.length;

  while (true){
    if (++guard > m*4) break; // 念のためブレーカ

    // (1) 矩形辺：cur → 次の交点（矩形順）
    const i = indexById.get(cur.id);
    const nxt = xsByU[(i+1)%m];
    const rectArc = rectPathBetween(cur, nxt, rect, clockwise);
    for(let k=1;k<rectArc.length;k++) res.push(rectArc[k].clone()); // 先頭重複を除く

    // (2) ポリライン：nxt → pair(nxt)
    const pid = pair.get(nxt.id);
    const peer = xsByU[indexById.get(pid)];
    const polySeg = polylineSliceBetween(poly2, nxt, peer);
    for(let k=1;k<polySeg.length;k++) res.push(polySeg[k].clone());

    cur = peer;
    if (cur.id === start.id) break; // 1周
  }

  // 閉じていなければ明示的に閉じる
  if (res.length>2 && res[0].distanceTo(res[res.length-1])>1e-6) res.push(res[0].clone());
  return res;
}

function perimeterLen(arr){
  let L=0; for(let i=0;i<arr.length-1;i++) L += arr[i].distanceTo(arr[i+1]); return L;
}
function polygonArea2D(pts){
  let a=0; for(let i=0;i<pts.length-1;i++){ const p=pts[i], q=pts[i+1]; a += p.x*q.y - q.x*p.y; }
  return a*0.5;
}
// 既存 dedupIntersections の“t”ではなく id/座標でまとめ直す
function dedupIntersectionsParamed(hits, eps=1e-7){
  // 位置重複を除去（u,s を平均寄せ）
  hits.sort((a,b)=> a.pt.x!==b.pt.x ? a.pt.x-b.pt.x : a.pt.y-b.pt.y);
  const out=[];
  for(const h of hits){
    const last = out[out.length-1];
    if(last && last.pt.distanceTo(h.pt) <= eps){
      // 併合（代表に近い方を残す）
      last.s = Math.min(last.s, h.s);
      last.u = Math.min(last.u, h.u);
    }else{
      out.push({...h});
    }
  }
  // id ふり直し
  for(let i=0;i<out.length;i++) out[i].id = i;
  return out;
}

// 線分 vs 矩形交差（変更なし）
function segmentRectIntersections(a,b,r,eps=1e-7){
  const hits=[];
  const tryEdge=(edge, p1, p2)=>{
    const h = segmentIntersection(a,b,p1,p2,eps);
    if(h){
      hits.push({pt:h, t:h._tAB, edge});
    }else{
      // ★ ほぼ接していて取りこぼすケースを救う：
      //   端点がエッジから ±EDGE_TOL 以内なら、その直交投影を交点として採用
      const ap = projectToEdgeIfNear(a, edge, r, EDGE_TOL);
      const bp = projectToEdgeIfNear(b, edge, r, EDGE_TOL);
      if (ap || bp) {
        // a→b のパラメータ t を出すため、投影点を使う
        const P = ap || bp;
        const t = paramOnSeg(P, a, b);
        const q = new THREE.Vector2(P.x, P.y); q._tAB = t;
        hits.push({pt:q, t, edge});
      }
    }
  };
  tryEdge('B', new THREE.Vector2(r.minX,r.minY), new THREE.Vector2(r.maxX,r.minY));
  tryEdge('R', new THREE.Vector2(r.maxX,r.minY), new THREE.Vector2(r.maxX,r.maxY));
  tryEdge('T', new THREE.Vector2(r.maxX,r.maxY), new THREE.Vector2(r.minX,r.maxY));
  tryEdge('L', new THREE.Vector2(r.minX,r.maxY), new THREE.Vector2(r.minX,r.minY));
  // t順で近接除去
  hits.sort((a,b)=>a.t-b.t);
  const out=[];
  for(const h of hits){
    if(!out.length || out[out.length-1].pt.distanceTo(h.pt)>eps) out.push(h);
  }
  return out;
}
// 補助：点がエッジに ±tol 以内なら直交投影を返す
function projectToEdgeIfNear(p, edge, r, tol){
  if (edge==='B' && Math.abs(p.y - r.minY) <= tol && p.x>=r.minX-tol && p.x<=r.maxX+tol)
    return new THREE.Vector2(THREE.MathUtils.clamp(p.x, r.minX, r.maxX), r.minY);
  if (edge==='T' && Math.abs(p.y - r.maxY) <= tol && p.x>=r.minX-tol && p.x<=r.maxX+tol)
    return new THREE.Vector2(THREE.MathUtils.clamp(p.x, r.minX, r.maxX), r.maxY);
  if (edge==='L' && Math.abs(p.x - r.minX) <= tol && p.y>=r.minY-tol && p.y<=r.maxY+tol)
    return new THREE.Vector2(r.minX, THREE.MathUtils.clamp(p.y, r.minY, r.maxY));
  if (edge==='R' && Math.abs(p.x - r.maxX) <= tol && p.y>=r.minY-tol && p.y<=r.maxY+tol)
    return new THREE.Vector2(r.maxX, THREE.MathUtils.clamp(p.y, r.minY, r.maxY));
  return null;
}
function segmentIntersection(a,b,c,d,eps=1e-7){
  const r = new THREE.Vector2().subVectors(b,a);
  const s = new THREE.Vector2().subVectors(d,c);
  const rxs = r.x*s.y - r.y*s.x;
  const qpxr = (c.x-a.x)*r.y - (c.y-a.y)*r.x;
  if (Math.abs(rxs) < eps && Math.abs(qpxr) < eps){
    const cand = [a,b,c,d];
    for(const p of cand){
      if (pointOnSegment(p,c,d,eps) && pointOnSegment(p,a,b,eps)){
        const t = paramOnSeg(p,a,b);
        const out = p.clone(); out._tAB = t;
        return out;
      }
    }
    return null;
  }
  if (Math.abs(rxs) < eps) return null;
  const t = ((c.x-a.x)*s.y - (c.y-a.y)*s.x) / rxs;
  const u = ((c.x-a.x)*r.y - (c.y-a.y)*r.x) / rxs;
  if (t>=-eps && t<=1+eps && u>=-eps && u<=1+eps){
    const p = new THREE.Vector2(a.x + t*r.x, a.y + t*r.y);
    p._tAB = t; return p;
  }
  return null;
}
function pointOnSegment(p,a,b,eps=1e-6){
  const ap = new THREE.Vector2().subVectors(p,a);
  const ab = new THREE.Vector2().subVectors(b,a);
  const cross = Math.abs(ap.x*ab.y - ap.y*ab.x);
  if (cross > eps) return false;
  const dot = ap.dot(ab);
  if (dot < -eps) return false;
  if (dot > ab.lengthSq()+eps) return false;
  return true;
}
function paramOnSeg(p,a,b){
  const ab = new THREE.Vector2().subVectors(b,a);
  const ap = new THREE.Vector2().subVectors(p,a);
  const len2 = ab.lengthSq()||1;
  return THREE.MathUtils.clamp(ap.dot(ab)/len2, 0, 1);
}
function dedupPolyline(arr, eps=1e-7){
  const out=[]; for(const p of arr){
    if(!out.length || out[out.length-1].distanceTo(p)>eps) out.push(p.clone());
  }
  if(out.length>2 && out[0].distanceTo(out[out.length-1])>eps) out.push(out[0].clone());
  return out;
}


function ensureFillMeshes(it){
  const side = (it.fillMode || ui.fillSide.value);
  const opacity = parseFloat(ui.fillOpacity.value);

  // 形状作成
  const g  = buildFillGeometry(it.pathPoints, side);
  const pg = buildFillGeometry(it.pathPoints, side);

  // ← ここで「面が作れたか」を判定（position が3頂点以上）
  const pos = g.getAttribute?.('position');
  const hasFill = !!(pos && pos.count >= 3);
  it.hasFill = hasFill;

  const color = it.userColor ? new THREE.Color(it.userColor)
                             : new THREE.Color(it.pipeMesh.material.color.getHex());
  const parent = it.parentGroup || it.pipeMesh.parent || rootLines;

  if(!it.fillMesh){
    it.fillMesh = new THREE.Mesh(
      g,
      new THREE.MeshStandardMaterial({
        color, roughness:.9, metalness:.02,
        side:THREE.DoubleSide, transparent:true, opacity
      })
    );
    it.pickFillMesh = new THREE.Mesh(
      pg,
      new THREE.MeshBasicMaterial({ color:0x000000, transparent:true, opacity:0.001, depthWrite:false })
    );
    it.pickFillMesh.renderOrder = -1000;
    parent.add(it.fillMesh, it.pickFillMesh);
  }else{
    it.fillMesh.geometry.dispose();
    it.fillMesh.geometry = g;
    it.fillMesh.material.opacity = opacity;
    it.fillMesh.material.transparent = opacity < 1;

    it.pickFillMesh.geometry.dispose();
    it.pickFillMesh.geometry = pg;

    if(it.fillMesh.parent !== parent){
      it.fillMesh.parent?.remove(it.fillMesh);
      it.pickFillMesh.parent?.remove(it.pickFillMesh);
      parent.add(it.fillMesh, it.pickFillMesh);
    }
  }

  // 面が無い場合は不可視化して誤ピックを防ぐ
  it.fillMesh.visible     = hasFill && ui.modeFill.checked && (it.ui?.vis?.checked ?? true);
  it.pickFillMesh.visible = hasFill && ui.modeFill.checked && (it.ui?.vis?.checked ?? true);
}


function buildTubeGeometry(points, radius){
  const curve=new THREE.CatmullRomCurve3(points,false,'centripetal',0.5);
  const seg=Math.max(16, Math.min(2048, Math.floor(points.length*1.5)));
  return new THREE.TubeGeometry(curve, seg, radius, 12, false);
}
function buildWallRibbonGeometry(points, width, miterEps=0.25){
  const n = points.length; if(n < 2) return new THREE.BoxGeometry(0,0,0);
  const half = width * 0.5;
  const dir = new Array(n);
  for(let i=0;i<n;i++){
    const a = points[Math.max(0,i-1)], b = points[Math.min(n-1,i+1)];
    const vx = b.x - a.x, vy = b.y - a.y;
    const l = Math.hypot(vx,vy) || 1;
    dir[i] = {x:vx/l, y:vy/l};
  }
  const left = new Array(n), right = new Array(n);
  for(let i=0;i<n;i++){
    const t0 = dir[Math.max(0,i-1)], t1 = dir[Math.min(n-1,i+1)];
    const n0 = {x:-t0.y, y:t0.x}, n1 = {x:-t1.y, y:t1.x};
    let ax = n0.x + n1.x, ay = n0.y + n1.y;
    const al = Math.hypot(ax,ay);
    if(al < 1e-6){ ax = n0.x; ay = n0.y; } else { ax/=al; ay/=al; }
    const dot = ax*n0.x + ay*n0.y;
    const scale = half / Math.max(Math.abs(dot), miterEps);
    const p = points[i];
    left[i]  = new THREE.Vector3(p.x + ax*scale, p.y + ay*scale, 0);
    right[i] = new THREE.Vector3(p.x - ax*scale, p.y - ay*scale, 0);
  }
  const positions = new Float32Array(n*4*3);
  const id = (i,k)=> i*4+k;
  for(let i=0;i<n;i++){
    const L=left[i], R=right[i];
    positions.set([L.x,L.y,0], (id(i,0))*3);
    positions.set([R.x,R.y,0], (id(i,1))*3);
    positions.set([L.x,L.y,1], (id(i,2))*3);
    positions.set([R.x,R.y,1], (id(i,3))*3);
  }
  const indices=[];
  for(let i=0;i<n-1;i++){
    const aLB=id(i,0), aRB=id(i,1), aLT=id(i,2), aRT=id(i,3);
    const bLB=id(i+1,0), bRB=id(i+1,1), bLT=id(i+1,2), bRT=id(i+1,3);
    indices.push(aLB,aLT,bLT,  aLB,bLT,bLB);
    indices.push(aRB,bRB,bRT,  aRB,bRT,aRT);
    indices.push(aLT,aRT,bRT,  aLT,bRT,bLT);
    indices.push(aLB,bLB,bRB,  aLB,bRB,aRB);
  }
  const g = new THREE.BufferGeometry();
  g.setAttribute('position', new THREE.BufferAttribute(positions,3));
  g.setIndex(indices);
  g.computeVertexNormals();
  return g;
}
function buildRectBandOnPlane(points3, width, thickness, planeNormal){
  const n = points3.length; if(n<2) return new THREE.BoxGeometry(0,0,0);
  const halfW = width*0.5, halfT = Math.max(0.0001, thickness*0.5);
  const tangents = new Array(n);
  for(let i=0;i<n;i++){
    const a=points3[Math.max(0,i-1)], b=points3[Math.min(n-1,i+1)];
    const t = new THREE.Vector3().subVectors(b,a); if(t.lengthSq()<1e-12) t.set(1,0,0);
    t.normalize(); tangents[i]=t;
  }
  const mArr=new Array(n);
  for(let i=0;i<n;i++){
    const m=new THREE.Vector3().crossVectors(planeNormal, tangents[i]);
    if(m.lengthSq()<1e-12){ m.copy(i>0?mArr[i-1]:new THREE.Vector3(1,0,0)); }
    m.normalize(); mArr[i]=m;
  }
  const positions = new Float32Array(n*4*3);
  const id=(i,k)=>i*4+k;
  for(let i=0;i<n;i++){
    const p=points3[i], m=mArr[i], up=planeNormal;
    const L = new THREE.Vector3().copy(p).addScaledVector(m, +halfW);
    const R = new THREE.Vector3().copy(p).addScaledVector(m, -halfW);
    const LB= new THREE.Vector3().copy(L).addScaledVector(up, -halfT);
    const RB= new THREE.Vector3().copy(R).addScaledVector(up, -halfT);
    const LT= new THREE.Vector3().copy(L).addScaledVector(up, +halfT);
    const RT= new THREE.Vector3().copy(R).addScaledVector(up, +halfT);
    positions.set([LB.x,LB.y,LB.z], (id(i,0))*3);
    positions.set([RB.x,RB.y,RB.z], (id(i,1))*3);
    positions.set([LT.x,LT.y,LT.z], (id(i,2))*3);
    positions.set([RT.x,RT.y,RT.z], (id(i,3))*3);
  }
  const indices=[];
  for(let i=0;i<n-1;i++){
    const aLB=id(i,0), aRB=id(i,1), aLT=id(i,2), aRT=id(i,3);
    const bLB=id(i+1,0), bRB=id(i+1,1), bLT=id(i+1,2), bRT=id(i+1,3);
    indices.push(aLB,aLT,bLT, aLB,bLT,bLB);
    indices.push(aRB,bRB,bRT, aRB,bRT,aRT);
    indices.push(aLT,aRT,bRT, aLT,bRT,bLT);
    indices.push(aLB,bLB,bRB, aLB,bRB,aRB);
  }
  const g=new THREE.BufferGeometry();
  g.setAttribute('position', new THREE.BufferAttribute(positions,3));
  g.setIndex(indices);
  g.computeVertexNormals();
  return g;
}
function itemSignature(it){
  const n = it.path2D?.length || 0;
  if(n < 2) return `${it.kind || 'svg'}:${n}`;

  const p0 = it.path2D[0];
  const pn = it.path2D[n - 1];

  // 始点・終点を方向非依存に正規化（辞書順で小→大）
  const a = [Math.round(p0.x), Math.round(p0.y)];
  const b = [Math.round(pn.x), Math.round(pn.y)];
  const [s0, s1] = (a[0] < b[0] || (a[0] === b[0] && a[1] <= b[1])) ? [a, b] : [b, a];

  // 署名の安定度を上げるために重心も入れる
  const cx = Math.round(it.centroid?.x || 0);
  const cy = Math.round(it.centroid?.y || 0);

  return [
    it.kind || 'svg',
    n,
    s0[0], s0[1],
    s1[0], s1[1],
    cx, cy
  ].join(':');
}

/* ==== 背景SVG ==== */
function readSvgDims(svgEl){
  const vb=svgEl.getAttribute("viewBox");
  if(vb){ const a=vb.trim().split(/\s+|,/).map(Number); if(a.length===4&&a.every(n=>isFinite(n))) return {minX:a[0],minY:a[1],w:a[2],h:a[3]}; }
  const w=parseFloat((svgEl.getAttribute("width")||"").replace(/[^\d.]+/g,""));
  const h=parseFloat((svgEl.getAttribute("height")||"").replace(/[^\d.]+/g,""));
  if(isFinite(w)&&isFinite(h)&&w>0&&h>0) return {minX:0,minY:0,w,h};
  return {minX:0,minY:0,w:1000,h:1000};
}
function normalizeSvgRoot(svgEl){
  const {minX,minY,w,h}=readSvgDims(svgEl);
  svgEl.setAttribute("width", String(w));
  svgEl.setAttribute("height", String(h));
  if(minX!==0 || minY!==0){
    const g = svgEl.ownerDocument.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute("transform",`translate(${-minX},${-minY})`);
    while(svgEl.firstChild) g.appendChild(svgEl.firstChild);
    svgEl.appendChild(g);
  }
  svgEl.setAttribute("viewBox",`0 0 ${w} ${h}`);
  return {w,h};
}
async function buildOrUpdateWeatherPlane(rawSvgText){
  if(!lastSvgDims) return; const {w,h}=lastSvgDims;
  const tex=await new THREE.TextureLoader().loadAsync('data:image/svg+xml;charset=utf-8,'+encodeURIComponent(rawSvgText));
  tex.colorSpace=THREE.SRGBColorSpace;
  tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
  tex.generateMipmaps = true;
  tex.minFilter = THREE.LinearMipmapLinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.flipY=false;
  const mat=new THREE.MeshBasicMaterial({map:tex, transparent:true, opacity:parseFloat(ui.imgOpacity.value), side:THREE.DoubleSide});
  const geom=new THREE.PlaneGeometry(w,h);
  if(!weatherPlane){ weatherPlane=new THREE.Mesh(geom,mat); weatherPlane.renderOrder=-1; chartGroup.add(weatherPlane); }
  else{
    weatherPlane.geometry.dispose();
    weatherPlane.material.map?.dispose();
    weatherPlane.material.dispose();
    weatherPlane.geometry=geom; weatherPlane.material=mat;
  }
  weatherPlane.position.set(0,0,0);
  weatherPlane.scale.set(1,-1,1);
  applyImageUI();
}
function applyImageUI(){
  if(!weatherPlane) return;
  weatherPlane.visible=ui.imgVisible.checked;
  weatherPlane.material.opacity=parseFloat(ui.imgOpacity.value);
  const s=parseFloat(ui.heightScale.value);
  weatherPlane.position.z=parseFloat(ui.imgHeight.value)*s;
}
['imgVisible','imgOpacity','imgHeight','heightScale'].forEach(id=>ui[id].addEventListener('input',applyImageUI));

/* ==== SVG → items ==== */
function centroidXY(pts){ let sx=0,sy=0; for(const p of pts){sx+=p.x;sy+=p.y;} const n=pts.length||1; return {x:sx/n,y:sy/n}; }
function polygonArea(pts){ let a=0; for(let i=0;i<pts.length;i++){ const p=pts[i], q=pts[(i+1)%pts.length]; a += p.x*q.y - q.x*p.y; } return Math.abs(a)/2; }

async function loadSVGFromString(svgText, opts = {}){
  rootLines.clear(); items=[]; ui.list.innerHTML='';

  const loader=new SVGLoader(); let data;
  try{ data=loader.parse(svgText); }catch(e){ console.error('SVG parse 失敗',e); return; }

  const linesGroup=new THREE.Group();
  // ★ここ：UIではなく opts から読む。なければ現在値をフォールバック
  const sampleN = Number.isFinite(opts.sampleN) ? opts.sampleN : parseInt(ui.sample.value,10);
  const radius  = ((Number.isFinite(opts.pipeDia) ? opts.pipeDia : parseFloat(ui.pipeDia.value)))/2;
  const bandW   = Number.isFinite(opts.wallThick) ? opts.wallThick : parseFloat(ui.wallThick.value);
  const wallOp  = Number.isFinite(opts.wallOpacity)? opts.wallOpacity: parseFloat(ui.wallOpacity.value);


  for(const p of data.paths){
    const style=p.userData?.style||{}; const stroke=(style.stroke && style.stroke!=='none')?style.stroke:"#9aa4b2";
    for(const sub of p.subPaths){
      const pts2=sub.getPoints(Math.max(2,sampleN)); if(pts2.length<2) continue;
      const pts3=pts2.map(pt=>new THREE.Vector3(+pt.x, -pt.y, 0));
      const pipeGeom = buildTubeGeometry(pts3, radius);
      const pipeMat  = new THREE.MeshStandardMaterial({color:new THREE.Color(stroke), roughness:.6, metalness:.06, side:THREE.DoubleSide});
      const pipeMesh = new THREE.Mesh(pipeGeom, pipeMat);
      const wallGeom = buildWallRibbonGeometry(pts3, bandW);
      const wallMat  = new THREE.MeshStandardMaterial({color:new THREE.Color(stroke), roughness:.7, metalness:.05, side:THREE.DoubleSide, transparent: wallOp<1, opacity: wallOp});
      const wallMesh = new THREE.Mesh(wallGeom, wallMat);
      const pickPipeGeom = buildTubeGeometry(pts3, radius * PICK_TUBE_SCALE);
      const pickPipeMat  = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.001, depthWrite:false});
      const pickPipeMesh = new THREE.Mesh(pickPipeGeom, pickPipeMat); pickPipeMesh.renderOrder = -1000;
      const pickWallGeom = buildWallRibbonGeometry(pts3, bandW * PICK_BAND_SCALE);
      const pickWallMat  = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.001, depthWrite:false});
      const pickWallMesh = new THREE.Mesh(pickWallGeom, pickWallMat); pickWallMesh.renderOrder = -1000;

      const cen=centroidXY(pts2), area=polygonArea(pts2);
      items.push({
        pipeMesh, wallMesh, pickPipeMesh, pickWallMesh,
        fillMesh:null, pickFillMesh:null,
        activeMesh:null, activePick:null,
        pathPoints:pts3, path2D: pts2.map(pt=>({x:+pt.x,y:+pt.y})),
        height:0, ui:{}, centroid:cen, pressure:undefined, area, autoTarget:0,
        userColor:null, wallExtrudedZ:true, kind:'svg',
        parentGroup: linesGroup, 
        fillMode: ui.fillSide.value
      });
      linesGroup.add(pipeMesh, wallMesh, pickPipeMesh, pickWallMesh);
      ensureFillMeshes(items[items.length-1]);
    }
  }

  const box=new THREE.Box3().setFromObject(linesGroup); const cen3=new THREE.Vector3(), sz=new THREE.Vector3();
  box.getCenter(cen3); box.getSize(sz);
  linesGroup.position.set(-cen3.x, -cen3.y, 0);
  rootLines.add(linesGroup);
  linesOffset.copy(linesGroup.position);

  const scale=600/Math.max(sz.x,sz.y); chartGroup.scale.setScalar(isFinite(scale)&&scale>0?scale:1);

  await assignPressuresFromLabelsOrAreas();
  applyModeVisibility();
  if (ui.autoMode.checked && !opts.suppressAuto) applyAutoHeights();
  buildList(true);
  updateHeightsAndColors();
  maybeFit();
}

/* ==== ラベル推定 ==== */
function parseTranslate(tf){ 
  let tx=0,ty=0; if(!tf) return {tx,ty};
  const m=tf.match(/matrix\(([^)]+)\)/);
  if(m){const a=m[1].split(/[ ,]+/).map(Number); if(a.length===6&&a.every(n=>isFinite(n))){tx+=a[4];ty+=a[5];}}
  const t=tf.match(/translate\(([^)]+)\)/);
  if(t){const a=t[1].split(/[ ,]+\s*/).map(Number); if(a.length>=1) tx+=a[0]||0; if(a.length>=2) ty+=a[1]||0;}
  return {tx,ty};
}
function estimateXY(el){ let x=parseFloat(el.getAttribute("x")||"0"), y=parseFloat(el.getAttribute("y")||"0"), cur=el; while(cur&&cur.nodeType===1){ const tf=cur.getAttribute&&cur.getAttribute("transform"); const {tx,ty}=parseTranslate(tf||""); x+=tx; y+=ty; cur=cur.parentNode; } return {x,y}; }
function readPressureLabels(svgText){
  const doc=new DOMParser().parseFromString(svgText,"image/svg+xml"); const svg=doc.querySelector("svg"); if(!svg) return [];
  const labels=[]; for(const t of doc.querySelectorAll("text")){
    const raw=(t.textContent||"").trim(); const m=raw.match(/(-?\d{3,4})/); if(!m) continue;
    const val=parseInt(m[1],10); if(!isFinite(val)||val<800||val>1100) continue;
    const {x,y}=estimateXY(t); labels.push({x,y,value:val});
  } return labels;
}
async function assignPressuresFromLabelsOrAreas(){
  const labs=readPressureLabels(lastRawSvgText);
  if(labs.length){
    ui.labelInfo.textContent=`検出ラベル: ${labs.length} 個`;
    for(const it of items){
      const {x,y}=it.centroid; let best=null,bd=Infinity;
      for(const lb of labs){ const d=(lb.x-x)**2+(lb.y-y)**2; if(d<bd){bd=d; best=lb;} }
      it.pressure=best?.value;
    }
  }else{
    ui.labelInfo.textContent='ラベルなし：面積ベースで自動配置';
    const arr=items.slice().sort((a,b)=>a.area-b.area);
    arr.forEach((it,idx)=>{ it.pressure=idx; });
  }
}

/* ==== auto / update ==== */
function applyAutoHeights(){
  const gf=parseFloat(ui.gapFactor.value);
  const blend=parseFloat(ui.autoBlend.value);
  const maxH=100*gf;
  const withP=items.filter(it=>isFinite(it.pressure)).sort((a,b)=>a.pressure-b.pressure);
  const n=withP.length;
  if(!n){ items.forEach(it=>it.height=0); updateHeightsAndColors(); return; }
  withP.forEach((it,idx)=>{ const t=(n===1)?0:(idx/(n-1)); it.autoTarget=t*maxH; });
  for(const it of items){ it.height=(it.autoTarget||0)*blend; }
  updateHeightsAndColors();
}
function updateHeightsAndColors(){
  const s=parseFloat(ui.heightScale.value);
  const maxH=currentMaxHeightStrict();
  for(const it of items){
    const z = it.height * s;

    it.pipeMesh.position.z = z;
    it.pickPipeMesh.position.z = z;

    if(it.wallExtrudedZ){
      it.wallMesh.scale.z    = Math.max(z, 0.0001);
      it.wallMesh.position.z = 0;
      it.pickWallMesh.scale.z    = Math.max(z, 0.0001);
      it.pickWallMesh.position.z = 0;
    }else{
      it.wallMesh.position.z = z;
      it.pickWallMesh.position.z = z;
      it.wallMesh.scale.z = 1;
      it.pickWallMesh.scale.z = 1;
    }
        // 面は「Z位置だけ」動かす（厚みはゼロ、XY面）
        if(it.fillMesh){
      it.fillMesh.position.z = z;
      it.pickFillMesh.position.z = z;

      // 色も線と統一（ユーザ色優先 / 自動カラー）
      const col = it.userColor ? new THREE.Color(it.userColor) : colorFromHeight(it.height, maxH);
      it.fillMesh.material.color.copy(col);
    }

    const col = it.userColor ? new THREE.Color(it.userColor) : colorFromHeight(it.height, maxH);
    it.pipeMesh.material.color.copy(col);
    it.wallMesh.material.color.copy(col);
    if(it.ui?.color) it.ui.color.value = `#${col.getHexString()}`;
  }
  
   // ここで1回だけ、必要なときだけ保存
 if (!suppressStateSave) {
   const t = tabs.find(t => t.id === activeTabId);
   if (t) t.itemsState = captureItemsState();
 }
}
function applyModeVisibility(){
  const showPipe = ui.modePipe.checked;
  const showWall = ui.modeWall.checked;
  const showFill = ui.modeFill.checked;

  for(const it of items){
    const visible = (it.ui?.vis?.checked ?? true);

    // 表示切り替え
    it.pipeMesh.visible     = showPipe && visible;
    it.wallMesh.visible     = showWall && visible;
    it.pickPipeMesh.visible = showPipe && visible;
    it.pickWallMesh.visible = showWall && visible;

    // ensureFillMeshes 側でも可視を調整するが、ここでも念のため
    if(it.fillMesh){
      const ok = !!it.hasFill && showFill && visible;
      it.fillMesh.visible     = ok;
      it.pickFillMesh.visible = ok;
    }

    // ドラッグ優先度：Fill(作れた時だけ) > Wall > Pipe
    if (showFill && it.fillMesh && it.hasFill && it.fillMesh.visible){
      it.activeMesh = it.fillMesh; it.activePick = it.pickFillMesh;
    } else if (showWall && it.wallMesh.visible){
      it.activeMesh = it.wallMesh; it.activePick = it.pickWallMesh;
    } else {
      it.activeMesh = it.pipeMesh; it.activePick = it.pickPipeMesh;
    }
  }
}

function rebuildAllFills(){
  for(const it of items){
    if(it.fillMesh){
      // pick含め一旦 dispose は不要（ensure 内で geometry 差し替え）
      ensureFillMeshes(it);
    }else{
      ensureFillMeshes(it);
    }
  }
  applyModeVisibility();
  updateHeightsAndColors();
}

ui.modeFill.addEventListener('change', ()=>{ applyModeVisibility(); });
ui.fillSide.addEventListener('change', ()=>{
  const v = ui.fillSide.value;
  for(const it of items){ it.fillMode = v; }
  rebuildAllFills();       // 🔧 全件を新しい既定に合わせる（手元で個別変更も可）
});
ui.fillOpacity.addEventListener('input', ()=>{
  const op = parseFloat(ui.fillOpacity.value);
  for(const it of items){
    if(it.fillMesh){
      it.fillMesh.material.opacity = op;
      it.fillMesh.material.transparent = op < 1;
    }
  }
});

/* フォーカススクロール */
function focusPanelCardForItem(it){
  const el = it?.ui?.card;
  if(!el) return;
  el.classList.add('focus-ring');
  el.setAttribute('tabindex','-1');
  el.scrollIntoView({block:'nearest', behavior:'smooth'});
  setTimeout(()=>el.classList.remove('focus-ring'), 900);
}

function buildList(orderByPressure=false){
  ui.list.innerHTML='';
  let arr=items.slice();
  if(orderByPressure){
    arr.sort((a,b)=>{
      const ap=isFinite(a.pressure)?a.pressure:Infinity;
      const bp=isFinite(b.pressure)?b.pressure:Infinity;
      return ap-bp;
    });
  }
  let i=0;
  for (const it of arr) {
  const card = document.createElement('div');
  card.className = 'card';

  const t = document.createElement('div');
  t.className = 't';

  const c = document.createElement('span');
  c.className = 'chip';
  c.textContent = `L${(++i).toString().padStart(3,'0')}`;

  // 表示チェック
  const vis = document.createElement('input');
  vis.type = 'checkbox';
  vis.checked = (it.ui?.vis?.checked ?? true);
  vis.title = '表示/非表示';
  vis.onchange = () => {
    applyModeVisibility();
    saveActiveTabState();    // ← 状態を保存
  };

  // 色入力
  const color = document.createElement('input');
  color.type = 'color';
  color.disabled = (it.kind === 'svg'); // SVGは自動色
  const initCol = it.userColor ? it.userColor
                               : `#${it.pipeMesh.material.color.getHexString()}`;
  color.value = initCol;
  color.oninput = () => {
    const v = color.value;
    it.userColor = v;
    it.pipeMesh.material.color.set(v);
    it.wallMesh.material.color.set(v);
    saveActiveTabState();    // ← 状態を保存
  };

  // タグ
  const tag = document.createElement('span');
  tag.className = 'small muted';
  tag.textContent = (it.kind === 'svg')
    ? (isFinite(it.pressure) ? `P=${it.pressure}` : `P=?`)
    : (it.kind === 'drawRect' ? '手描き帯' : '手描きチューブ');

  t.append(c, vis, color, tag);
  card.appendChild(t);

  // スライダー
  const row1 = document.createElement('div');
  row1.className = 'row';
  const lab = document.createElement('label');
  lab.textContent = '高さ（Z）';
  const slider = document.createElement('input');
  slider.type = 'range';
  slider.min = -2000; slider.max = 2000; slider.step = 0.1;
  slider.value = it.height;
  slider.oninput = () => {
    it.height = parseFloat(slider.value);
    if (it.ui?.num) it.ui.num.value = it.height.toFixed(2);
    updateHeightsAndColors();
  };
  row1.append(lab, slider);
  card.appendChild(row1);

  // 数値入力
  const row2 = document.createElement('div');
  row2.className = 'row';
  const hint = document.createElement('span');
  hint.className = 'small';
  hint.textContent = '数字でも調整できます';
  const num = document.createElement('input');
  num.type = 'number';
  num.className = 'small';
  num.step = 0.1;
  num.style.width = '110px';
  num.value = it.height.toFixed(2);
  num.onchange = () => {
    const v = parseFloat(num.value) || 0;
    it.height = v;
    slider.value = v;
    updateHeightsAndColors();
  };
  row2.append(hint, num);
  card.appendChild(row2);
  // 面の張り方（個別）
  const row3 = document.createElement('div');
  row3.className = 'row';
  const lab3 = document.createElement('label');
  lab3.textContent = '面の張り方（この線）';
  const sel3 = document.createElement('select');
  sel3.innerHTML = `
    <option value="inside">輪郭の内側</option>
    <option value="outside">輪郭の外側</option>
  `;
  sel3.value = it.fillMode || 'inside';
  sel3.onchange = () => {
    it.fillMode = sel3.value;
    ensureFillMeshes(it);   // その場で作り直し
    applyModeVisibility();
    updateHeightsAndColors();
  };
  row3.append(lab3, sel3);
  card.appendChild(row3);
  // UI参照を保存
  it.ui = { slider, num, color, vis, card };
  ui.list.appendChild(card);
}

applyModeVisibility();

}

/* ==== ピック & ドラッグ ==== */
const raycaster=new THREE.Raycaster(); const pointer=new THREE.Vector2();
let draggingItem=null; let lastClientY=0;
function pickFromClientXY(clientX, clientY){
  const rect=ui.canvas.getBoundingClientRect();
  pointer.set((clientX-rect.left)/rect.width*2-1, -(clientY-rect.top)/rect.height*2+1);
  raycaster.setFromCamera(pointer,camera);
  const targets = items.map(i=>i.activePick).filter(m=>m && m.visible);
  const hits = raycaster.intersectObjects(targets, false);
  if(!hits[0]) return null;
  const obj = hits[0].object;
  return items.find(it => it.activePick===obj);
}
function updateHudByClientXY(clientX, clientY, h){
  const rect=ui.canvas.getBoundingClientRect();
  ui.dragHud.style.left = (clientX-rect.left)+'px';
  ui.dragHud.style.top  = (clientY-rect.top)+'px';
  const maxH=currentMaxHeightStrict();
  const col=colorFromHeight(h,maxH);
  const r=Math.round(col.r*255), g=Math.round(col.g*255), b=Math.round(col.b*255);
  ui.dragHud.style.background=`rgba(${r},${g},${b},.9)`;
  ui.dragHud.textContent=`Z = ${h.toFixed(2)}`;
}

/* ==== 手描き ==== */
const drawState = { enabled:false, drawing:false, pts:[], tempMesh:null, tempPick:null, plane:new THREE.Plane(new THREE.Vector3(0,0,1),0) };
function updateDrawPlaneFromCamera(){
  const n = new THREE.Vector3();
  camera.getWorldDirection(n).normalize();
  drawState.plane.set(n, 0);
}
function screenToPlanePoint(clientX, clientY){
  const rect=ui.canvas.getBoundingClientRect();
  pointer.set((clientX-rect.left)/rect.width*2-1, -(clientY-rect.top)/rect.height*2+1);
  raycaster.setFromCamera(pointer,camera);
  const p = new THREE.Vector3();
  if(raycaster.ray.intersectPlane(drawState.plane, p)) return p;
  return null;
}
function buildOrUpdateTemp(){
  const col = new THREE.Color(ui.drawColor.value);
  const shape = ui.drawShape.value;
  if(drawState.pts.length<2){
    if(drawState.tempMesh){ drawState.tempMesh.visible=false; drawState.tempPick.visible=false; }
    return;
  }

  let geom, pickGeom, mat, pickMat;
  if(shape==='tube'){
    const dia = parseFloat(ui.drawDiaOrWidth.value);
    geom = buildTubeGeometry(drawState.pts, dia/2);
    pickGeom = buildTubeGeometry(drawState.pts, (dia/2)*PICK_TUBE_SCALE);
  }else{
    const width = parseFloat(ui.drawDiaOrWidth.value);
    const thick = parseFloat(ui.drawThickness.value);
    const n = drawState.plane.normal.clone().normalize();
    geom = buildRectBandOnPlane(drawState.pts, width, thick, n);
    pickGeom = buildRectBandOnPlane(drawState.pts, width*PICK_BAND_SCALE, thick*PICK_BAND_SCALE, n);
  }
  mat = new THREE.MeshStandardMaterial({color:col, roughness:.6, metalness:.06, side:THREE.DoubleSide});
  pickMat = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.001, depthWrite:false});

  if(!drawState.tempMesh){
    drawState.tempMesh = new THREE.Mesh(geom, mat);
    drawState.tempPick = new THREE.Mesh(pickGeom, pickMat);
    drawState.tempPick.renderOrder=-1000;
    chartGroup.add(drawState.tempMesh, drawState.tempPick);
  }else{
    drawState.tempMesh.geometry.dispose();
    drawState.tempMesh.geometry = geom;
    drawState.tempMesh.material.color.copy(col);
    drawState.tempPick.geometry.dispose();
    drawState.tempPick.geometry = pickGeom;
  }
  drawState.tempMesh.visible = true;
  drawState.tempPick.visible = true;
}
function commitTempToItem(){
  if(!drawState.tempMesh) return;
  const col = new THREE.Color(ui.drawColor.value);
  const shape = ui.drawShape.value;
  const width = parseFloat(ui.drawDiaOrWidth.value);
  const thick = parseFloat(ui.drawThickness.value);
  const n = drawState.plane.normal.clone().normalize();

  let pipeMesh, wallMesh, pickPipeMesh, pickWallMesh, kind, wallExtrudedZ;

  if(shape==='tube'){
    const pts3 = drawState.pts.map(p=> p.clone());
    pipeMesh = new THREE.Mesh(buildTubeGeometry(pts3, width/2), new THREE.MeshStandardMaterial({color:col, roughness:.6, metalness:.06, side:THREE.DoubleSide}));
    const w = Math.max(parseFloat(ui.wallThick.value), 0.5);
    wallMesh = new THREE.Mesh(buildRectBandOnPlane(pts3, w, Math.max(1, w*0.4), n), new THREE.MeshStandardMaterial({color:col, roughness:.6, metalness:.06, side:THREE.DoubleSide, transparent:true, opacity:parseFloat(ui.wallOpacity.value)}));
    pickPipeMesh = new THREE.Mesh(buildTubeGeometry(pts3, (width/2)*PICK_TUBE_SCALE), new THREE.MeshBasicMaterial({color:0x000000,transparent:true,opacity:0.001,depthWrite:false}));
    pickWallMesh = new THREE.Mesh(buildRectBandOnPlane(pts3, w*PICK_BAND_SCALE, Math.max(1, w*0.4)*PICK_BAND_SCALE, n), new THREE.MeshBasicMaterial({color:0x000000,transparent:true,opacity:0.001,depthWrite:false}));
    kind='drawTube'; wallExtrudedZ=false;
  }else{
    const pts3 = drawState.pts.map(p=> p.clone());
    wallMesh = new THREE.Mesh(buildRectBandOnPlane(pts3, width, thick, n), new THREE.MeshStandardMaterial({color:col, roughness:.6, metalness:.06, side:THREE.DoubleSide}));
    pipeMesh = new THREE.Mesh(new THREE.BoxGeometry(0,0,0), new THREE.MeshBasicMaterial({visible:false}));
    pickWallMesh = new THREE.Mesh(buildRectBandOnPlane(pts3, width*PICK_BAND_SCALE, thick*PICK_BAND_SCALE, n), new THREE.MeshBasicMaterial({color:0x000000,transparent:true,opacity:0.001,depthWrite:false}));
    pickPipeMesh = new THREE.Mesh(new THREE.BoxGeometry(0,0,0), new THREE.MeshBasicMaterial({visible:false}));
    kind='drawRect'; wallExtrudedZ=false;
  }

  const it = {
    pipeMesh, wallMesh, pickPipeMesh, pickWallMesh,
    activeMesh:null, activePick:null,
    pathPoints: drawState.pts.map(p=> p.clone()),
    path2D: drawState.pts.map(p=>({x:p.x, y:-p.y})),
    height: 0, ui:{}, centroid:{x:0,y:0}, pressure:undefined, area:0, autoTarget:0,
    userColor: `#${col.getHexString()}`, wallExtrudedZ, kind,
    parentGroup: rootLines, 
    fillMode: ui.fillSide.value
  };
  items.push(it);
  rootLines.add(pipeMesh, wallMesh, pickPipeMesh, pickWallMesh);

  drawState.tempMesh.geometry.dispose();
  drawState.tempPick.geometry.dispose();
  chartGroup.remove(drawState.tempMesh, drawState.tempPick);
  drawState.tempMesh=null; drawState.tempPick=null;
  drawState.pts.length=0;

  buildList(false);
  updateHeightsAndColors();

  if(kind==='drawRect' && !ui.modeWall.checked){
    ui.modeWall.checked = true;
  }
  applyModeVisibility();
  const currentTab = tabs.find(t => t.id === activeTabId);
  if (currentTab) currentTab.itemsState = captureItemsState();
}

/* ==== Pointer ==== */
ui.canvas.addEventListener('pointerdown',(e)=>{
  const drawOn = ui.drawEnable.checked;
  if(drawOn){
    updateDrawPlaneFromCamera();
    const p = screenToPlanePoint(e.clientX, e.clientY);
    if(!p) return;
    controls.enabled=false;
    ui.canvas.setPointerCapture(e.pointerId);
    Object.assign(drawState, {drawing:true, pts:[p.clone()]});
    buildOrUpdateTemp();
    e.preventDefault();
    return;
  }

  if(e.button!==0) return;
  const hit = pickFromClientXY(e.clientX, e.clientY);
  if(hit){
    draggingItem = hit;
    lastClientY = e.clientY;
    controls.enabled = false;
    ui.canvas.classList.add('grabbing');
    ui.dragHud.style.display='block';
    focusPanelCardForItem(draggingItem);
    updateHudByClientXY(e.clientX, e.clientY, draggingItem.height);
    ui.canvas.setPointerCapture(e.pointerId);
    e.preventDefault();
  }
});
ui.canvas.addEventListener('pointermove',(e)=>{
  if(drawState.drawing){
    const p = screenToPlanePoint(e.clientX, e.clientY);
    if(!p) return;
    const last=drawState.pts[drawState.pts.length-1];
    const minStep = Math.max(0.5, (20 - parseInt(ui.drawSampling.value,10))*0.5);
    if(!last || p.distanceTo(last)>minStep){
      drawState.pts.push(p.clone());
      buildOrUpdateTemp();
    }
    e.preventDefault();
    return;
  }
  if(draggingItem){
    const dy = e.clientY - lastClientY; lastClientY = e.clientY;
    let sens=parseFloat(ui.dragSensitivity.value);
    if(e.shiftKey) sens*=.2; if(e.altKey) sens*=3.0;
    draggingItem.height += -dy * sens;

    if(draggingItem.ui?.slider) draggingItem.ui.slider.value=draggingItem.height;
    if(draggingItem.ui?.num)    draggingItem.ui.num.value=draggingItem.height.toFixed(2);

    updateHeightsAndColors();
    updateHudByClientXY(e.clientX, e.clientY, draggingItem.height);
    e.preventDefault();
    return;
  }
  const over = pickFromClientXY(e.clientX, e.clientY);
  ui.canvas.classList.toggle('hovering', !!over && !ui.drawEnable.checked);
});
function endDrawOrDrag(e){
  if(drawState.drawing){
    drawState.drawing=false;
    controls.enabled=true;
    commitTempToItem();
    if(e) ui.canvas.releasePointerCapture(e.pointerId);
    return;
  }
  if(draggingItem){
    updateHeightsAndColors();
    draggingItem=null;
    controls.enabled=true;
    ui.canvas.classList.remove('grabbing');
    ui.dragHud.style.display='none';
    if(e) ui.canvas.releasePointerCapture(e.pointerId);
  }
}
ui.canvas.addEventListener('pointerup', endDrawOrDrag);
ui.canvas.addEventListener('pointercancel', endDrawOrDrag);
ui.canvas.addEventListener('pointerleave', (e)=>{ if(drawState.drawing || draggingItem) endDrawOrDrag(e); });

/* ==== I/O ==== */
function tryDecodeUtf8(u8){ try{ const txt=new TextDecoder("utf-8",{fatal:false}).decode(u8); if(txt.includes("<svg")||txt.includes("<?xml")) return txt; }catch{} return null; }
async function readSvgOrSvgz(file){
  const buf=await file.arrayBuffer(); const u8=new Uint8Array(buf);
  const plain=tryDecodeUtf8(u8); if(plain) return plain;
  const isGzip=u8.length>=2 && u8[0]===0x1f && u8[1]===0x8b;
  if(isGzip || (file.name||"").toLowerCase().endsWith(".svgz")){
    try{ const t=new TextDecoder("utf-8").decode(pako.ungzip(u8)); if(t.includes("<svg")) return t; }catch(e1){
      try{ const t=new TextDecoder("utf-8").decode(pako.inflate(u8)); if(t.includes("<svg")) return t; }catch(e2){
        try{ const t=new TextDecoder("utf-8").decode(pako.inflateRaw(u8)); if(t.includes("<svg")) return t; }catch(e3){}
      }
    }
  }
  const fb=new TextDecoder("utf-8",{fatal:false}).decode(u8);
  if(fb && fb.includes("<svg")) return fb;
  throw new Error("SVGZの解凍に失敗しました。");
}
function extractIsobarsOnly(svgText){
  const doc=new DOMParser().parseFromString(svgText,"image/svg+xml");
  const svg=doc.querySelector("svg"); if(!svg) return svgText; 
  const {w,h}=normalizeSvgRoot(svg);
  lastSvgDims={w,h};
  const contours=svg.querySelectorAll('g#weatherChart g.contour');
  const outDoc=document.implementation.createDocument("http://www.w3.org/2000/svg","svg",null);
  const outSvg=outDoc.documentElement; outSvg.setAttribute("xmlns","http://www.w3.org/2000/svg");
  outSvg.setAttribute("viewBox",`0 0 ${w} ${h}`); outSvg.setAttribute("width",String(w)); outSvg.setAttribute("height",String(h));
  const DEFAULT_STROKE="#9aa4b2";
  contours.forEach(cont=>{
    cont.querySelectorAll("path, polyline, circle, rect, ellipse").forEach(el=>{
      const dup=el.cloneNode(true);
      dup.setAttribute("fill","none");
      if(!dup.getAttribute("stroke")||dup.getAttribute("stroke")==="none") dup.setAttribute("stroke",DEFAULT_STROKE);
      if(!dup.getAttribute("stroke-width")) dup.setAttribute("stroke-width","1");
      outSvg.appendChild(dup);
    });
  });
  if(!outSvg.firstElementChild) return new XMLSerializer().serializeToString(svg);
  return new XMLSerializer().serializeToString(outSvg);
}

/* ==== 保存（正規化座標） ==== */
function pointsToAttr2D(points){ return points.map(p=>`${(+p.x).toFixed(3)},${(+p.y).toFixed(3)}`).join(' '); }
function pointsToAttr3D(points){ return points.map(p=>`${(+p.x).toFixed(3)} ${(+p.y).toFixed(3)} ${(+p.z).toFixed(3)}`).join(';'); }
function getCanonicalPts3(it){
  if(it.kind === 'svg') return it.pathPoints.map(p=>p.clone());
  return it.pathPoints.map(p=> new THREE.Vector3(p.x - linesOffset.x, p.y - linesOffset.y, p.z));
}
function canonical3Dto2D(pts3){ return pts3.map(v=>({x:v.x, y:-v.y})); }

function buildProjectSVG(){
  const doc = document.implementation.createDocument("http://www.w3.org/2000/svg","svg",null);
  const svg = doc.documentElement;
  svg.setAttribute("xmlns","http://www.w3.org/2000/svg");
  if(lastSvgDims){ svg.setAttribute("viewBox",`0 0 ${lastSvgDims.w} ${lastSvgDims.h}`); svg.setAttribute("width",String(lastSvgDims.w)); svg.setAttribute("height",String(lastSvgDims.h)); }
  svg.setAttribute("data-app","3disobarsplus");

  if(lastRawSvgText){
    const bgDoc = new DOMParser().parseFromString(lastRawSvgText,"image/svg+xml");
    const bgRoot = bgDoc.querySelector("svg");
    if(bgRoot){
      const g = doc.createElementNS("http://www.w3.org/2000/svg","g");
      g.setAttribute("id","weatherEmbedded");
      for(const node of Array.from(bgRoot.childNodes)){
        g.appendChild(doc.importNode(node,true));
      }
      svg.appendChild(g);
    }
  }

  const iso = doc.createElementNS("http://www.w3.org/2000/svg","g");
  iso.setAttribute("id","isobars3d");
  iso.setAttribute("data-app","3disobarsplus");
  iso.setAttribute("data-version","6");
  for(const it of items){
    const ptsCanon3 = getCanonicalPts3(it);
    const pts2 = canonical3Dto2D(ptsCanon3);
    const poly = doc.createElementNS("http://www.w3.org/2000/svg","polyline");
    poly.setAttribute("fill","none");
    const col = it.userColor ? it.userColor : `#${it.pipeMesh.material.color.getHexString()}`;
    poly.setAttribute("stroke", col);
    poly.setAttribute("stroke-width","1");
    poly.setAttribute("points", pointsToAttr2D(pts2));
    poly.setAttribute("data-pts3", pointsToAttr3D(ptsCanon3));
    poly.setAttribute("data-height", String(+it.height.toFixed(3)));
    poly.setAttribute("data-visible", (it.ui?.vis?.checked ?? true) ? "1":"0");
    poly.setAttribute("data-kind", it.kind||'svg');
    poly.setAttribute("data-wall-extruded", it.wallExtrudedZ? "1":"0");
    poly.setAttribute("data-usercolor", it.userColor ? "1":"0");
    iso.appendChild(poly);
  }
  svg.appendChild(iso);

  const meta = doc.createElementNS("http://www.w3.org/2000/svg","metadata");
  meta.textContent = JSON.stringify({
    app:"3disobarsplus",
    savedAt: new Date().toISOString(),
    autoMode: ui.autoMode.checked,
    heightScale: parseFloat(ui.heightScale.value)
  });
  svg.appendChild(meta);

  return new XMLSerializer().serializeToString(svg);
}
function doSaveSVG(){
  const svgText = buildProjectSVG();
  const blob = new Blob([svgText], {type:"image/svg+xml"});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = '3disobarsplus.svg';
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href),1000);
}
function doExportSTL(){
  const exporter=new STLExporter();
  const group=new THREE.Group();
  for(const it of items){
    const visible = (it.ui?.vis?.checked ?? true);
    if(!visible) continue;
    if(it.pipeMesh.visible) group.add(it.pipeMesh.clone());
    if(it.wallMesh.visible) group.add(it.wallMesh.clone());
  }
  const stl=exporter.parse(group);
  const blob=new Blob([stl],{type:'model/stl'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='isobars.stl'; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
}

/* ==== 保存SVGの再読込 ==== */
function parsePts3Attr(str){
  const out=[]; if(!str) return out;
  str.split(';').forEach(tok=>{
    const [x,y,z]=tok.trim().split(/[ ,]+/).map(Number);
    if(isFinite(x)&&isFinite(y)&&isFinite(z)) out.push(new THREE.Vector3(x,y,z));
  });
  return out;
}
function parsePointsAttr2D(str){
  const out=[]; if(!str) return out;
  str.trim().split(/\s+/).forEach(tok=>{
    const [x,y]=tok.split(',').map(Number);
    if(isFinite(x)&&isFinite(y)) out.push({x,y});
  });
  return out;
}
async function loadProjectSVG(svgText){
  const doc = new DOMParser().parseFromString(svgText,"image/svg+xml");
  const svg = doc.querySelector("svg");
  if(!svg){ console.warn('SVGルートが見つかりません'); return; }

  const {w,h}=normalizeSvgRoot(svg);
  lastSvgDims={w,h};

  const svgClone = svg.cloneNode(true);
  const iso = svgClone.querySelector('g#isobars3d[data-app="3disobarsplus"]');
  if(iso) iso.parentNode.removeChild(iso);
  const bgText = new XMLSerializer().serializeToString(svgClone);
  lastRawSvgText = bgText;
  await buildOrUpdateWeatherPlane(bgText);

  rootLines.clear(); items=[]; ui.list.innerHTML='';
  const isoGroup = svg.querySelector('g#isobars3d[data-app="3disobarsplus"]');
  if(!isoGroup){ console.warn('isobars3d グループが見つかりません'); return; }

  const radius=parseFloat(ui.pipeDia.value)/2;
  const bandW =parseFloat(ui.wallThick.value);
  const wallOp=parseFloat(ui.wallOpacity.value);

  const linesGroup=new THREE.Group();
  const polylines = Array.from(isoGroup.querySelectorAll('polyline'));
  for(const poly of polylines){
    const kind = poly.getAttribute('data-kind')||'svg';
    const pts3 = parsePts3Attr(poly.getAttribute('data-pts3')||'');
    const pts2 = parsePointsAttr2D(poly.getAttribute('points')||'');
    const height = parseFloat(poly.getAttribute('data-height')||'0')||0;
    const stroke = poly.getAttribute('stroke') || '#9aa4b2';
    const visible = poly.getAttribute('data-visible')!=="0";
    const wallExtrudedZ = poly.getAttribute('data-wall-extruded')==="1";
    const userColorFlag = poly.getAttribute('data-usercolor');

    const pathPoints = (pts3.length? pts3 : pts2.map(p=>new THREE.Vector3(p.x, -p.y, 0)));

    let pipeMesh, wallMesh, pickPipeMesh, pickWallMesh, wallExZ;

    if(kind==='drawRect'){
      const normal = new THREE.Vector3(0,0,1);
      wallMesh = new THREE.Mesh(buildRectBandOnPlane(pathPoints, Math.max(bandW,1), Math.max(1,bandW*0.4), normal), new THREE.MeshStandardMaterial({color:new THREE.Color(stroke), roughness:.6, metalness:.06, side:THREE.DoubleSide, transparent:true, opacity:wallOp}));
      pipeMesh = new THREE.Mesh(new THREE.BoxGeometry(0,0,0), new THREE.MeshBasicMaterial({visible:false}));
      pickWallMesh = new THREE.Mesh(buildRectBandOnPlane(pathPoints, Math.max(bandW,1)*PICK_BAND_SCALE, Math.max(1,bandW*0.4)*PICK_BAND_SCALE, normal), new THREE.MeshBasicMaterial({color:0x000000,transparent:true,opacity:0.001,depthWrite:false}));
      pickPipeMesh = new THREE.Mesh(new THREE.BoxGeometry(0,0,0), new THREE.MeshBasicMaterial({visible:false}));
      wallExZ=false;
    }else{
      pipeMesh = new THREE.Mesh(buildTubeGeometry(pathPoints, radius), new THREE.MeshStandardMaterial({color:new THREE.Color(stroke), roughness:.6, metalness:.06, side:THREE.DoubleSide}));
      if(wallExtrudedZ || kind==='svg'){
        wallMesh = new THREE.Mesh(buildWallRibbonGeometry(pathPoints, bandW), new THREE.MeshStandardMaterial({color:new THREE.Color(stroke), roughness:.7, metalness:.05, side:THREE.DoubleSide, transparent: wallOp<1, opacity: wallOp}));
        pickWallMesh = new THREE.Mesh(buildWallRibbonGeometry(pathPoints, bandW*PICK_BAND_SCALE), new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.001, depthWrite:false}));
        wallExZ=true;
      }else{
        const normal = new THREE.Vector3(0,0,1);
        wallMesh = new THREE.Mesh(buildRectBandOnPlane(pathPoints, Math.max(bandW,1), Math.max(1,bandW*0.4), normal), new THREE.MeshStandardMaterial({color:new THREE.Color(stroke), roughness:.6, metalness:.06, side:THREE.DoubleSide, transparent:true, opacity:wallOp}));
        pickWallMesh = new THREE.Mesh(buildRectBandOnPlane(pathPoints, Math.max(bandW,1)*PICK_BAND_SCALE, Math.max(1,bandW*0.4)*PICK_BAND_SCALE, normal), new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.001, depthWrite:false}));
        wallExZ=false;
      }
      pickPipeMesh = new THREE.Mesh(buildTubeGeometry(pathPoints, radius * PICK_TUBE_SCALE), new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.001, depthWrite:false}));
    }

    const userColor =
      (userColorFlag === '1') ? stroke :
      (kind !== 'svg' && userColorFlag !== '0') ? stroke : null;
    const cen = pts2.length ? centroidXY(pts2) : centroidXY(canonical3Dto2D(pathPoints));
    const it = {
      pipeMesh, wallMesh, pickPipeMesh, pickWallMesh,
      fillMesh:null, pickFillMesh:null,
      activeMesh:null, activePick:null,
      pathPoints, path2D: pts2,
      height, ui:{}, centroid: cen, pressure:undefined, area:0, autoTarget:0,
      userColor, wallExtrudedZ: (wallExZ ?? wallExtrudedZ), kind,
      parentGroup: linesGroup, 
      fillMode: ui.fillSide.value
    };
    items.push(it);
    linesGroup.add(pipeMesh, wallMesh, pickPipeMesh, pickWallMesh);
    ensureFillMeshes(it);
    it.ui.vis = {checked:visible};
    pipeMesh.visible = visible && ui.modePipe.checked;
    wallMesh.visible = visible && ui.modeWall.checked;
    pickPipeMesh.visible = visible && ui.modePipe.checked;
    pickWallMesh.visible = visible && ui.modeWall.checked;
  }

  const box=new THREE.Box3().setFromObject(linesGroup); const cen3=new THREE.Vector3(), sz=new THREE.Vector3();
  box.getCenter(cen3); box.getSize(sz);
  linesGroup.position.set(-cen3.x, -cen3.y, 0);
  rootLines.add(linesGroup);
  linesOffset.copy(linesGroup.position);

  const scale=600/Math.max(sz.x,sz.y); chartGroup.scale.setScalar(isFinite(scale)&&scale>0?scale:1);

  buildList(true);
  updateHeightsAndColors();
  applyModeVisibility();
  maybeFit();
}

/* ==== メニュー ==== */
function toggleMenu(menu, anchorBtn){
  const open = !menu.classList.contains('open');
  document.querySelectorAll('.menu.open').forEach(m=>m.classList.remove('open'));
  if(!open) return;
  const r = anchorBtn.getBoundingClientRect();
  menu.style.left = (r.left)+'px';
  menu.style.top  = (r.bottom+4)+'px';
  menu.classList.add('open');
}
function closeMenus(){ document.querySelectorAll('.menu.open').forEach(m=>m.classList.remove('open')); }
document.getElementById('openBtn').addEventListener('click', ()=> toggleMenu(ui.openMenu, ui.openBtn));
document.getElementById('exportBtn').addEventListener('click', ()=> toggleMenu(ui.exportMenu, ui.exportBtn));
addEventListener('click', (e)=>{
  if(!e.target.closest('.menu') && ![ui.openBtn, ui.exportBtn].includes(e.target)) closeMenus();
});
ui.openMenu.addEventListener('click', (e)=>{
  const act = e.target?.dataset?.act; if(!act) return;
  closeMenus();
  if(act==='open-raw') ui.fileRaw.click();
  if(act==='open-saved') ui.fileSaved.click();
});
ui.exportMenu.addEventListener('click', (e)=>{
  const act = e.target?.dataset?.act; if(!act) return;
  closeMenus();
  if(act==='export-stl') doExportSTL();
  if(act==='save-svg')  doSaveSVG();
});

// ▼ SVG/SVGZ を開く（完全差し替え）
ui.fileRaw.addEventListener('change', async (e)=>{
  const f = e.target.files?.[0]; 
  if(!f) return;

  try{
    // いま開いているタブの状態を先に保存
    saveActiveTabState();

    // 新しいファイルは“ここでは”シーンに読み込まない
    const raw = await readSvgOrSvgz(f);
    const doc = new DOMParser().parseFromString(raw, "image/svg+xml");
    const svg = doc.querySelector("svg");
    if(!svg) return;

    // ルート正規化と各種テキスト化
    const { w, h } = normalizeSvgRoot(svg);
    const rawSvgText = new XMLSerializer().serializeToString(svg);
    const onlyIsobars = extractIsobarsOnly(raw);

    // タブを作る。実際の読み込みは activateTab() 側で行われる
    addTabFromRaw(f.name, rawSvgText, onlyIsobars, { w, h });

  }catch(err){
    console.error('読み込みエラー', err);
  }finally{
    // 同じファイルを続けて選んだときのために input をリセット
    e.target.value = '';
  }
});

// ▼ 保存SVG（本アプリ）を開く（完全差し替え）
ui.fileSaved.addEventListener('change', async (e)=>{
  const f = e.target.files?.[0]; 
  if(!f) return;

  try{
    // いま開いているタブの状態を先に保存
    saveActiveTabState();

    // ここでは読み込まない。テキストだけ確保してタブ化
    const projectText = await f.text();
    addTabFromProject(f.name, projectText);

  }catch(err){
    console.error('読み込みエラー', err);
  }finally{
    e.target.value = '';
  }
});


/* ==== その他UI ==== */
ui.bgColor.addEventListener('input', e=>{ scene.background=new THREE.Color(e.target.value); });
ui.basisVisible.addEventListener('change', e=>{ basis.visible=e.target.checked; });
ui.gridVisible.addEventListener('change', e=>{ const v=e.target.checked; gridXY.visible=v; gridZX.visible=v; });
ui.heightScale.addEventListener('input', ()=>{ updateHeightsAndColors(); applyImageUI(); });
ui.viewSelect.addEventListener('change', e=>{ const v=e.target.value; if(v==='top') viewTop(); else if(v==='front') viewFront(); else if(v==='side') viewSide(); else fitView(chartGroup); });
ui.projection.addEventListener('change', e=>{ (e.target.value==='ortho')?useOrthographic():usePerspective(); fitView(chartGroup); });
ui.panelToggle.addEventListener('click', ()=>{ const open=ui.app.getAttribute('data-panel')!=='closed'; ui.app.setAttribute('data-panel', open?'closed':'open'); setTimeout(resize,0); });
ui.autoMode.addEventListener('change', ()=>{
  if(ui.autoMode.checked) applyAutoHeights();
  else { for(const it of items){ it.height=0; if(it.ui?.slider) it.ui.slider.value=0; if(it.ui?.num) it.ui.num.value='0.00'; } updateHeightsAndColors(); }
});
ui.gapFactor.addEventListener('input', ()=>{ if(ui.autoMode.checked) applyAutoHeights(); });
ui.autoBlend.addEventListener('input', ()=>{
  if(ui.autoMode.checked) applyAutoHeights();
});
function syncMode(){ applyModeVisibility(); updateHeightsAndColors(); }
ui.modePipe.addEventListener('change', syncMode);
ui.modeWall.addEventListener('change', syncMode);
ui.pipeDia.addEventListener('input', ()=>{
  const r=parseFloat(ui.pipeDia.value)/2;
  for(const it of items){
    const oldV=it.pipeMesh.geometry; it.pipeMesh.geometry=buildTubeGeometry(it.pathPoints, r); oldV.dispose();
    const oldP=it.pickPipeMesh.geometry; it.pickPipeMesh.geometry=buildTubeGeometry(it.pathPoints, r*PICK_TUBE_SCALE); oldP.dispose();
  }
  updateHeightsAndColors();
});
ui.wallThick.addEventListener('input', ()=>{
  const w=parseFloat(ui.wallThick.value);
  for(const it of items){
    if(it.wallExtrudedZ){
      const oldV=it.wallMesh.geometry; it.wallMesh.geometry=buildWallRibbonGeometry(it.pathPoints, w); oldV.dispose();
      const oldP=it.pickWallMesh.geometry; it.pickWallMesh.geometry=buildWallRibbonGeometry(it.pathPoints, w*PICK_BAND_SCALE); oldP.dispose();
    }else{
      const normal=new THREE.Vector3(0,0,1);
      const oldV=it.wallMesh.geometry; it.wallMesh.geometry=buildRectBandOnPlane(it.pathPoints, Math.max(w,1), Math.max(1,w*0.4), normal); oldV.dispose();
      const oldP=it.pickWallMesh.geometry; it.pickWallMesh.geometry=buildRectBandOnPlane(it.pathPoints, Math.max(w,1)*PICK_BAND_SCALE, Math.max(1,w*0.4)*PICK_BAND_SCALE, normal); oldP.dispose();
    }
  }
});
ui.wallOpacity.addEventListener('input', ()=>{
  const op=parseFloat(ui.wallOpacity.value);
  for(const it of items){ it.wallMesh.material.opacity=op; it.wallMesh.material.transparent = op<1; }
});

/* 初期可視 */
basis.visible=true; gridXY.visible=true; gridZX.visible=true;
</script>
</body>
</html>
